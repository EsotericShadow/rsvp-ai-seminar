{"instruction": "How does LeadMine integration work?", "input": "Explain the LeadMine API integration and business data sync", "output": "I'll explain the complete LeadMine integration system. Here's how business data is synchronized and managed:\n\n**LEADMINE INTEGRATION SYSTEM**\n\n**1. LEADMINE API CLIENT**\n```typescript\n// LeadMine API client implementation\n// src/lib/leadMine.ts\nexport type LeadMineBusiness = {\n  id: string;\n  name: string | null;\n  address: string | null;\n  website: string | null;\n  createdAt: string;\n  contact: {\n    primaryEmail: string | null;\n    alternateEmail: string | null;\n    contactPerson: string | null;\n    tags: string[];\n  };\n  lead: {\n    status: string | null;\n    priority: string | null;\n    assignedTo: string | null;\n    nextFollowUpDate: string | null;\n  };\n  invite: {\n    token: string;\n    emailsSent: number;\n    lastEmailSent: string | null;\n    visitsCount: number;\n    lastVisitedAt: string | null;\n    rsvpsCount: number;\n    lastRsvpAt: string | null;\n    lastEmailMeta?: Record<string, unknown> | null;\n    lastVisitMeta?: Record<string, unknown> | null;\n    lastRsvpMeta?: Record<string, unknown> | null;\n  } | null;\n};\n\nexport type LeadMineBusinessesResponse = {\n  data: LeadMineBusiness[];\n  pagination: {\n    limit: number;\n    nextCursor: string | null;\n  };\n};\n\n// LeadMine API client\nasync function leadMineFetch<T>(path: string, init?: RequestInit): Promise<T> {\n  const baseUrl = process.env.LEADMINE_API_BASE;\n  const apiKey = process.env.LEADMINE_API_KEY;\n  \n  if (!baseUrl || !apiKey) {\n    throw new Error('LeadMine integration not configured');\n  }\n\n  const res = await fetch(`${baseUrl}${path}`, {\n    ...init,\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n      'Content-Type': 'application/json',\n      ...(init?.headers || {}),\n    },\n    cache: 'no-store',\n  });\n\n  if (!res.ok) {\n    const text = await res.text().catch(() => '');\n    throw new Error(`LeadMine request failed (${res.status}): ${text}`);\n  }\n\n  return res.json() as Promise<T>;\n}\n```\n\n**2. BUSINESS DATA FETCHING**\n```typescript\n// Fetch businesses from LeadMine\nexport async function fetchLeadMineBusinesses(params: {\n  limit?: number;\n  cursor?: string;\n  hasEmail?: boolean;\n  createMissing?: boolean;\n  ids?: string[];\n  search?: string;\n} = {}): Promise<LeadMineBusinessesResponse> {\n  const searchParams = new URLSearchParams();\n  \n  if (params.limit) searchParams.set('limit', params.limit.toString());\n  if (params.cursor) searchParams.set('cursor', params.cursor);\n  if (params.hasEmail !== undefined) searchParams.set('hasEmail', params.hasEmail.toString());\n  if (params.createMissing !== undefined) searchParams.set('createMissing', params.createMissing.toString());\n  if (params.ids) searchParams.set('ids', params.ids.join(','));\n  if (params.search) searchParams.set('search', params.search);\n  \n  const queryString = searchParams.toString();\n  const path = `/businesses${queryString ? `?${queryString}` : ''}`;\n  \n  return leadMineFetch<LeadMineBusinessesResponse>(path);\n}\n\n// Fetch specific business by ID\nexport async function fetchLeadMineBusiness(businessId: string): Promise<LeadMineBusiness> {\n  return leadMineFetch<LeadMineBusiness>(`/businesses/${businessId}`);\n}\n```\n\n**3. INVITE TOKEN MANAGEMENT**\n```typescript\n// Get or create invite token for business\nexport async function getOrCreateInviteToken(businessId: string): Promise<string> {\n  try {\n    // First try to get existing token from local database\n    const existingMember = await prisma.audienceMember.findFirst({\n      where: {\n        businessId,\n        inviteToken: {\n          not: null,\n        },\n      },\n      select: {\n        inviteToken: true,\n      },\n    });\n    \n    if (existingMember?.inviteToken) {\n      return existingMember.inviteToken;\n    }\n    \n    // If no local token, fetch from LeadMine\n    const business = await fetchLeadMineBusiness(businessId);\n    \n    if (business.invite?.token) {\n      // Update local database with token\n      await prisma.audienceMember.updateMany({\n        where: {\n          businessId,\n        },\n        data: {\n          inviteToken: business.invite.token,\n        },\n      });\n      \n      return business.invite.token;\n    }\n    \n    throw new Error('No invite token available for business');\n  } catch (error) {\n    console.error('Error getting invite token:', error);\n    throw error;\n  }\n}\n```\n\n**4. EVENT POSTING TO LEADMINE**\n```typescript\n// Post events to LeadMine\nexport async function postLeadMineEvent(eventData: {\n  token: string;\n  businessId: string;\n  type: string;\n  meta: Record<string, any>;\n}): Promise<void> {\n  try {\n    await leadMineFetch('/events', {\n      method: 'POST',\n      body: JSON.stringify(eventData),\n    });\n  } catch (error) {\n    console.error('Error posting event to LeadMine:', error);\n    // Don't throw - this is not critical for the main flow\n  }\n}\n\n// Post RSVP event\nexport async function postRSVPEvent(rsvpData: {\n  rsvpId: string;\n  email: string;\n  attendanceStatus: string;\n  attendeeCount: number;\n  businessId?: string;\n  inviteToken?: string;\n}) {\n  await postLeadMineEvent({\n    token: rsvpData.inviteToken || 'rsvp-submission',\n    businessId: rsvpData.businessId || rsvpData.rsvpId,\n    type: 'rsvp_submitted',\n    meta: {\n      rsvpId: rsvpData.rsvpId,\n      email: rsvpData.email,\n      attendanceStatus: rsvpData.attendanceStatus,\n      attendeeCount: rsvpData.attendeeCount,\n      submittedAt: new Date().toISOString(),\n    },\n  });\n}\n\n// Post email engagement event\nexport async function postEmailEngagementEvent(engagementData: {\n  token: string;\n  businessId: string;\n  type: 'email_sent' | 'email_opened' | 'email_clicked' | 'email_replied';\n  campaignId?: string;\n  scheduleId?: string;\n  meta?: Record<string, any>;\n}) {\n  await postLeadMineEvent({\n    token: engagementData.token,\n    businessId: engagementData.businessId,\n    type: engagementData.type,\n    meta: {\n      campaignId: engagementData.campaignId,\n      scheduleId: engagementData.scheduleId,\n      ...engagementData.meta,\n      timestamp: new Date().toISOString(),\n    },\n  });\n}\n```\n\n**5. BUSINESS DATA SYNCHRONIZATION**\n```typescript\n// Sync business data from LeadMine to local database\nexport async function syncBusinessData(\n  groupId: string,\n  businessIds?: string[]\n): Promise<{\n  synced: number;\n  errors: number;\n  errors: string[];\n}> {\n  const results = {\n    synced: 0,\n    errors: 0,\n    errors: [] as string[]\n  };\n\n  try {\n    // Fetch businesses from LeadMine\n    const leadMineResponse = await fetchLeadMineBusinesses({\n      ids: businessIds,\n      hasEmail: true,\n      createMissing: true,\n    });\n\n    // Sync each business\n    for (const business of leadMineResponse.data) {\n      try {\n        await syncBusinessToGroup(groupId, business);\n        results.synced++;\n      } catch (error) {\n        results.errors++;\n        results.errors.push(`Failed to sync business ${business.id}: ${error.message}`);\n      }\n    }\n  } catch (error) {\n    results.errors++;\n    results.errors.push(`Failed to fetch from LeadMine: ${error.message}`);\n  }\n\n  return results;\n}\n\n// Sync individual business to group\nasync function syncBusinessToGroup(groupId: string, business: LeadMineBusiness) {\n  const memberData = {\n    businessId: business.id,\n    businessName: business.name,\n    primaryEmail: business.contact.primaryEmail,\n    secondaryEmail: business.contact.alternateEmail,\n    tagsSnapshot: business.contact.tags,\n    inviteToken: business.invite?.token,\n    meta: {\n      lastSynced: new Date().toISOString(),\n      leadMineData: {\n        address: business.address,\n        website: business.website,\n        contactPerson: business.contact.contactPerson,\n        leadStatus: business.lead.status,\n        leadPriority: business.lead.priority,\n        assignedTo: business.lead.assignedTo,\n        nextFollowUpDate: business.lead.nextFollowUpDate,\n        inviteData: business.invite ? {\n          emailsSent: business.invite.emailsSent,\n          lastEmailSent: business.invite.lastEmailSent,\n          visitsCount: business.invite.visitsCount,\n          lastVisitedAt: business.invite.lastVisitedAt,\n          rsvpsCount: business.invite.rsvpsCount,\n          lastRsvpAt: business.invite.lastRsvpAt,\n        } : null,\n      },\n    },\n  };\n\n  // Check if member already exists\n  const existingMember = await prisma.audienceMember.findUnique({\n    where: {\n      groupId_businessId: {\n        groupId,\n        businessId: business.id,\n      },\n    },\n  });\n\n  if (existingMember) {\n    // Update existing member\n    await prisma.audienceMember.update({\n      where: {\n        groupId_businessId: {\n          groupId,\n          businessId: business.id,\n        },\n      },\n      data: memberData,\n    });\n  } else {\n    // Create new member\n    await prisma.audienceMember.create({\n      data: {\n        groupId,\n        ...memberData,\n      },\n    });\n  }\n}\n```\n\n**6. LEADMINE CONFIGURATION**\n```typescript\n// LeadMine configuration and health check\nexport function getLeadMineConfig(): {\n  configured: boolean;\n  baseUrl?: string;\n  apiKey?: string;\n} {\n  const baseUrl = process.env.LEADMINE_API_BASE;\n  const apiKey = process.env.LEADMINE_API_KEY;\n  \n  return {\n    configured: Boolean(baseUrl && apiKey),\n    baseUrl,\n    apiKey: apiKey ? '***' + apiKey.slice(-4) : undefined,\n  };\n}\n\nexport async function testLeadMineConnection(): Promise<{\n  success: boolean;\n  error?: string;\n}> {\n  try {\n    const config = getLeadMineConfig();\n    if (!config.configured) {\n      return {\n        success: false,\n        error: 'LeadMine not configured',\n      };\n    }\n\n    // Test with a simple request\n    await fetchLeadMineBusinesses({ limit: 1 });\n    \n    return { success: true };\n  } catch (error) {\n    return {\n      success: false,\n      error: error.message,\n    };\n  }\n}\n```\n\n**7. CAMPAIGN INTEGRATION**\n```typescript\n// LeadMine integration in campaign sending\n// src/lib/campaigns.ts\nexport async function recordSendEngagement(\n  businessId: string,\n  inviteToken: string,\n  engagementType: 'email_sent' | 'email_opened' | 'email_clicked',\n  campaignId?: string,\n  scheduleId?: string,\n  meta?: Record<string, any>\n) {\n  try {\n    // Post to LeadMine\n    await postEmailEngagementEvent({\n      token: inviteToken,\n      businessId,\n      type: engagementType,\n      campaignId,\n      scheduleId,\n      meta,\n    });\n  } catch (error) {\n    console.error('Error recording engagement:', error);\n    // Don't throw - this is not critical for the main flow\n  }\n}\n\n// Update LeadMine when campaign is sent\nexport async function updateLeadMineOnCampaignSend(\n  businessId: string,\n  inviteToken: string,\n  campaignId: string,\n  scheduleId: string,\n  emailData: {\n    subject: string;\n    html: string;\n    text: string;\n  }\n) {\n  await postEmailEngagementEvent({\n    token: inviteToken,\n    businessId,\n    type: 'email_sent',\n    campaignId,\n    scheduleId,\n    meta: {\n      subject: emailData.subject,\n      contentLength: emailData.html.length,\n      textLength: emailData.text.length,\n    },\n  });\n}\n```\n\n**8. ERROR HANDLING AND RETRY LOGIC**\n```typescript\n// LeadMine error handling with retry logic\nexport async function leadMineFetchWithRetry<T>(\n  path: string,\n  init?: RequestInit,\n  maxRetries: number = 3\n): Promise<T> {\n  let lastError: Error;\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await leadMineFetch<T>(path, init);\n    } catch (error) {\n      lastError = error;\n      \n      // Don't retry on client errors (4xx)\n      if (error.message.includes('(4')) {\n        throw error;\n      }\n      \n      // Wait before retry (exponential backoff)\n      if (attempt < maxRetries) {\n        const delay = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  \n  throw lastError;\n}\n\n// Safe LeadMine operations that don't fail the main flow\nexport async function safeLeadMineOperation<T>(\n  operation: () => Promise<T>,\n  fallback?: T\n): Promise<T | undefined> {\n  try {\n    return await operation();\n  } catch (error) {\n    console.error('LeadMine operation failed:', error);\n    return fallback;\n  }\n}\n```\n\n**9. LEADMINE ANALYTICS**\n```typescript\n// LeadMine analytics and reporting\nexport async function getLeadMineAnalytics(groupId: string): Promise<{\n  totalBusinesses: number;\n  businessesWithEmail: number;\n  businessesWithInviteToken: number;\n  totalEmailsSent: number;\n  totalVisits: number;\n  totalRSVPs: number;\n  engagementRate: number;\n}> {\n  const members = await prisma.audienceMember.findMany({\n    where: { groupId },\n    select: {\n      businessId: true,\n      primaryEmail: true,\n      inviteToken: true,\n      meta: true,\n    },\n  });\n\n  const analytics = {\n    totalBusinesses: members.length,\n    businessesWithEmail: members.filter(m => m.primaryEmail).length,\n    businessesWithInviteToken: members.filter(m => m.inviteToken).length,\n    totalEmailsSent: 0,\n    totalVisits: 0,\n    totalRSVPs: 0,\n    engagementRate: 0,\n  };\n\n  // Calculate engagement metrics from meta data\n  for (const member of members) {\n    const leadMineData = member.meta?.leadMineData;\n    if (leadMineData?.inviteData) {\n      analytics.totalEmailsSent += leadMineData.inviteData.emailsSent || 0;\n      analytics.totalVisits += leadMineData.inviteData.visitsCount || 0;\n      analytics.totalRSVPs += leadMineData.inviteData.rsvpsCount || 0;\n    }\n  }\n\n  // Calculate engagement rate\n  if (analytics.totalEmailsSent > 0) {\n    analytics.engagementRate = (analytics.totalVisits / analytics.totalEmailsSent) * 100;\n  }\n\n  return analytics;\n}\n```\n\n**10. LEADMINE WEBHOOK INTEGRATION**\n```typescript\n// LeadMine webhook handling (if applicable)\nexport async function handleLeadMineWebhook(req: Request): Promise<NextResponse> {\n  try {\n    const body = await req.json();\n    const { type, data } = body;\n\n    switch (type) {\n      case 'business_updated':\n        await handleBusinessUpdate(data);\n        break;\n      case 'business_deleted':\n        await handleBusinessDeletion(data);\n        break;\n      case 'invite_token_generated':\n        await handleInviteTokenGenerated(data);\n        break;\n      default:\n        console.log('Unknown LeadMine webhook type:', type);\n    }\n\n    return NextResponse.json({ success: true });\n  } catch (error) {\n    console.error('LeadMine webhook error:', error);\n    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 });\n  }\n}\n\nasync function handleBusinessUpdate(businessData: LeadMineBusiness) {\n  // Update all audience members with this business ID\n  await prisma.audienceMember.updateMany({\n    where: { businessId: businessData.id },\n    data: {\n      businessName: businessData.name,\n      primaryEmail: businessData.contact.primaryEmail,\n      secondaryEmail: businessData.contact.alternateEmail,\n      tagsSnapshot: businessData.contact.tags,\n      inviteToken: businessData.invite?.token,\n      meta: {\n        lastSynced: new Date().toISOString(),\n        leadMineData: {\n          address: businessData.address,\n          website: businessData.website,\n          contactPerson: businessData.contact.contactPerson,\n          leadStatus: businessData.lead.status,\n          leadPriority: businessData.lead.priority,\n          assignedTo: businessData.lead.assignedTo,\n          nextFollowUpDate: businessData.lead.nextFollowUpDate,\n        },\n      },\n    },\n  });\n}\n\nasync function handleBusinessDeletion(businessData: { id: string }) {\n  // Remove all audience members with this business ID\n  await prisma.audienceMember.deleteMany({\n    where: { businessId: businessData.id },\n  });\n}\n\nasync function handleInviteTokenGenerated(data: { businessId: string; token: string }) {\n  // Update audience members with new invite token\n  await prisma.audienceMember.updateMany({\n    where: { businessId: data.businessId },\n    data: {\n      inviteToken: data.token,\n      meta: {\n        inviteTokenGeneratedAt: new Date().toISOString(),\n      },\n    },\n  });\n}\n```\n\nThis LeadMine integration provides comprehensive business data synchronization, event tracking, and analytics integration for your RSVP application's audience management system."}


