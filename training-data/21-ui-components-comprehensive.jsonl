{"instruction": "How do React UI components work in this application?", "input": "Explain the complete UI component system including design patterns, state management, and user interactions", "output": "I'll explain the comprehensive UI component system. Here's how React components are structured and how they work together:\n\n**UI COMPONENT ARCHITECTURE SYSTEM**\n\n**1. COMPONENT DESIGN PATTERNS**\n```typescript\n// Base component pattern with TypeScript interfaces\n// src/components/base/BaseComponent.tsx\ninterface BaseComponentProps {\n  children?: React.ReactNode;\n  className?: string;\n  id?: string;\n  'data-testid'?: string;\n}\n\ninterface BaseComponentState {\n  isLoading: boolean;\n  error: string | null;\n  data: any;\n}\n\nexport abstract class BaseComponent<P extends BaseComponentProps, S extends BaseComponentState> \n  extends React.Component<P, S> {\n  \n  constructor(props: P) {\n    super(props);\n    this.state = this.getInitialState();\n  }\n  \n  abstract getInitialState(): S;\n  abstract renderContent(): React.ReactNode;\n  \n  render() {\n    const { className, id, 'data-testid': testId } = this.props;\n    const { isLoading, error } = this.state;\n    \n    if (isLoading) {\n      return <LoadingSpinner />;\n    }\n    \n    if (error) {\n      return <ErrorMessage message={error} />;\n    }\n    \n    return (\n      <div \n        className={`base-component ${className || ''}`}\n        id={id}\n        data-testid={testId}\n      >\n        {this.renderContent()}\n      </div>\n    );\n  }\n}\n```\n\n**2. FORM COMPONENT SYSTEM**\n```typescript\n// Multi-step form with validation and state management\n// src/components/forms/MultiStepForm.tsx\ninterface FormStep {\n  id: string;\n  title: string;\n  description?: string;\n  component: React.ComponentType<any>;\n  validation?: (data: any) => boolean;\n  required?: boolean;\n}\n\ninterface MultiStepFormProps {\n  steps: FormStep[];\n  initialData?: any;\n  onSubmit: (data: any) => Promise<void>;\n  onStepChange?: (stepIndex: number, data: any) => void;\n  className?: string;\n}\n\nexport function MultiStepForm({ \n  steps, \n  initialData = {}, \n  onSubmit, \n  onStepChange,\n  className \n}: MultiStepFormProps) {\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState(initialData);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  \n  // Step navigation logic\n  const goToNextStep = async () => {\n    const currentStepConfig = steps[currentStep];\n    \n    // Validate current step\n    if (currentStepConfig.validation && !currentStepConfig.validation(formData)) {\n      setErrors({ step: 'Please complete all required fields' });\n      return;\n    }\n    \n    // Clear errors\n    setErrors({});\n    \n    // Notify parent of step change\n    if (onStepChange) {\n      onStepChange(currentStep + 1, formData);\n    }\n    \n    // Move to next step\n    if (currentStep < steps.length - 1) {\n      setCurrentStep(currentStep + 1);\n    }\n  };\n  \n  const goToPreviousStep = () => {\n    if (currentStep > 0) {\n      setCurrentStep(currentStep - 1);\n      if (onStepChange) {\n        onStepChange(currentStep - 1, formData);\n      }\n    }\n  };\n  \n  const handleSubmit = async () => {\n    setIsSubmitting(true);\n    try {\n      await onSubmit(formData);\n    } catch (error) {\n      setErrors({ submit: error.message });\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  \n  const updateFormData = (stepData: any) => {\n    setFormData(prev => ({ ...prev, ...stepData }));\n  };\n  \n  return (\n    <div className={`multi-step-form ${className || ''}`}>\n      {/* Progress indicator */}\n      <FormProgress \n        currentStep={currentStep}\n        totalSteps={steps.length}\n        steps={steps}\n      />\n      \n      {/* Current step content */}\n      <div className=\"step-content\">\n        <div className=\"step-header\">\n          <h2 className=\"step-title\">{steps[currentStep].title}</h2>\n          {steps[currentStep].description && (\n            <p className=\"step-description\">{steps[currentStep].description}</p>\n          )}\n        </div>\n        \n        <div className=\"step-body\">\n          {React.createElement(steps[currentStep].component, {\n            data: formData,\n            onChange: updateFormData,\n            errors: errors,\n            isSubmitting: isSubmitting\n          })}\n        </div>\n      </div>\n      \n      {/* Navigation buttons */}\n      <div className=\"step-navigation\">\n        <button\n          type=\"button\"\n          onClick={goToPreviousStep}\n          disabled={currentStep === 0}\n          className=\"btn-secondary\"\n        >\n          Previous\n        </button>\n        \n        {currentStep < steps.length - 1 ? (\n          <button\n            type=\"button\"\n            onClick={goToNextStep}\n            className=\"btn-primary\"\n          >\n            Next\n          </button>\n        ) : (\n          <button\n            type=\"button\"\n            onClick={handleSubmit}\n            disabled={isSubmitting}\n            className=\"btn-primary\"\n          >\n            {isSubmitting ? 'Submitting...' : 'Submit'}\n          </button>\n        )}\n      </div>\n      \n      {/* Error display */}\n      {Object.keys(errors).length > 0 && (\n        <div className=\"form-errors\">\n          {Object.entries(errors).map(([key, message]) => (\n            <div key={key} className=\"error-message\">\n              {message}\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**3. STATE MANAGEMENT PATTERNS**\n```typescript\n// Custom hooks for state management\n// src/hooks/useFormState.ts\ninterface UseFormStateOptions<T> {\n  initialValues: T;\n  validation?: (values: T) => Record<string, string>;\n  onSubmit: (values: T) => Promise<void>;\n  resetOnSubmit?: boolean;\n}\n\nexport function useFormState<T extends Record<string, any>>({\n  initialValues,\n  validation,\n  onSubmit,\n  resetOnSubmit = true\n}: UseFormStateOptions<T>) {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  const [touched, setTouched] = useState<Record<string, boolean>>({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  \n  // Update field value\n  const setValue = useCallback((field: keyof T, value: any) => {\n    setValues(prev => ({ ...prev, [field]: value }));\n    \n    // Clear error when user starts typing\n    if (errors[field as string]) {\n      setErrors(prev => {\n        const newErrors = { ...prev };\n        delete newErrors[field as string];\n        return newErrors;\n      });\n    }\n  }, [errors]);\n  \n  // Mark field as touched\n  const setTouchedField = useCallback((field: keyof T) => {\n    setTouched(prev => ({ ...prev, [field]: true }));\n  }, []);\n  \n  // Validate form\n  const validate = useCallback(() => {\n    if (!validation) return true;\n    \n    const validationErrors = validation(values);\n    setErrors(validationErrors);\n    \n    return Object.keys(validationErrors).length === 0;\n  }, [values, validation]);\n  \n  // Handle form submission\n  const handleSubmit = useCallback(async (e?: React.FormEvent) => {\n    if (e) e.preventDefault();\n    \n    // Mark all fields as touched\n    const allTouched = Object.keys(values).reduce((acc, key) => {\n      acc[key] = true;\n      return acc;\n    }, {} as Record<string, boolean>);\n    setTouched(allTouched);\n    \n    // Validate form\n    if (!validate()) {\n      return;\n    }\n    \n    setIsSubmitting(true);\n    try {\n      await onSubmit(values);\n      \n      if (resetOnSubmit) {\n        setValues(initialValues);\n        setErrors({});\n        setTouched({});\n      }\n    } catch (error) {\n      setErrors({ submit: error.message });\n    } finally {\n      setIsSubmitting(false);\n    }\n  }, [values, validate, onSubmit, resetOnSubmit, initialValues]);\n  \n  // Reset form\n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n    setTouched({});\n    setIsSubmitting(false);\n  }, [initialValues]);\n  \n  return {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    setValue,\n    setTouchedField,\n    handleSubmit,\n    validate,\n    reset\n  };\n}\n```\n\n**4. COMPONENT COMPOSITION PATTERNS**\n```typescript\n// Higher-order component for common functionality\n// src/components/hoc/withLoading.tsx\ninterface WithLoadingProps {\n  isLoading: boolean;\n  loadingMessage?: string;\n}\n\nexport function withLoading<P extends object>(\n  WrappedComponent: React.ComponentType<P>\n) {\n  return function WithLoadingComponent(props: P & WithLoadingProps) {\n    const { isLoading, loadingMessage = 'Loading...', ...rest } = props;\n    \n    if (isLoading) {\n      return (\n        <div className=\"loading-container\">\n          <div className=\"loading-spinner\">\n            <div className=\"spinner\"></div>\n            <p className=\"loading-text\">{loadingMessage}</p>\n          </div>\n        </div>\n      );\n    }\n    \n    return <WrappedComponent {...(rest as P)} />;\n  };\n}\n\n// Usage example\nconst UserProfileWithLoading = withLoading(UserProfile);\n\n// Render prop pattern for data fetching\n// src/components/patterns/DataProvider.tsx\ninterface DataProviderProps<T> {\n  fetchData: () => Promise<T>;\n  children: (data: {\n    data: T | null;\n    loading: boolean;\n    error: string | null;\n    refetch: () => void;\n  }) => React.ReactNode;\n}\n\nexport function DataProvider<T>({ fetchData, children }: DataProviderProps<T>) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  const fetch = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await fetchData();\n      setData(result);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [fetchData]);\n  \n  useEffect(() => {\n    fetch();\n  }, [fetch]);\n  \n  return (\n    <>\n      {children({ data, loading, error, refetch: fetch })}\n    </>\n  );\n}\n```\n\n**5. ACCESSIBILITY PATTERNS**\n```typescript\n// Accessible form components\n// src/components/accessible/AccessibleInput.tsx\ninterface AccessibleInputProps {\n  label: string;\n  id: string;\n  type?: string;\n  value: string;\n  onChange: (value: string) => void;\n  error?: string;\n  required?: boolean;\n  description?: string;\n  placeholder?: string;\n  disabled?: boolean;\n}\n\nexport function AccessibleInput({\n  label,\n  id,\n  type = 'text',\n  value,\n  onChange,\n  error,\n  required = false,\n  description,\n  placeholder,\n  disabled = false\n}: AccessibleInputProps) {\n  const errorId = `${id}-error`;\n  const descriptionId = `${id}-description`;\n  const hasError = Boolean(error);\n  \n  return (\n    <div className=\"form-field\">\n      <label \n        htmlFor={id}\n        className={`form-label ${hasError ? 'error' : ''}`}\n      >\n        {label}\n        {required && <span className=\"required-indicator\" aria-label=\"required\">*</span>}\n      </label>\n      \n      {description && (\n        <p id={descriptionId} className=\"field-description\">\n          {description}\n        </p>\n      )}\n      \n      <input\n        id={id}\n        type={type}\n        value={value}\n        onChange={(e) => onChange(e.target.value)}\n        placeholder={placeholder}\n        disabled={disabled}\n        required={required}\n        aria-invalid={hasError}\n        aria-describedby={`${hasError ? errorId : ''} ${description ? descriptionId : ''}`.trim()}\n        className={`form-input ${hasError ? 'error' : ''}`}\n      />\n      \n      {error && (\n        <div \n          id={errorId}\n          className=\"error-message\"\n          role=\"alert\"\n          aria-live=\"polite\"\n        >\n          {error}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Focus management for modals\n// src/components/accessible/FocusManager.tsx\nexport function useFocusManagement() {\n  const focusableElementsRef = useRef<HTMLElement[]>([]);\n  const previousActiveElementRef = useRef<HTMLElement | null>(null);\n  \n  const trapFocus = useCallback((container: HTMLElement) => {\n    const focusableSelectors = [\n      'button:not([disabled])',\n      'input:not([disabled])',\n      'select:not([disabled])',\n      'textarea:not([disabled])',\n      '[tabindex]:not([tabindex=\"-1\"])',\n      'a[href]'\n    ];\n    \n    focusableElementsRef.current = Array.from(\n      container.querySelectorAll(focusableSelectors.join(', '))\n    ) as HTMLElement[];\n    \n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Tab') {\n        const firstElement = focusableElementsRef.current[0];\n        const lastElement = focusableElementsRef.current[focusableElementsRef.current.length - 1];\n        \n        if (e.shiftKey) {\n          if (document.activeElement === firstElement) {\n            e.preventDefault();\n            lastElement.focus();\n          }\n        } else {\n          if (document.activeElement === lastElement) {\n            e.preventDefault();\n            firstElement.focus();\n          }\n        }\n      }\n    };\n    \n    container.addEventListener('keydown', handleKeyDown);\n    \n    return () => {\n      container.removeEventListener('keydown', handleKeyDown);\n    };\n  }, []);\n  \n  const saveFocus = useCallback(() => {\n    previousActiveElementRef.current = document.activeElement as HTMLElement;\n  }, []);\n  \n  const restoreFocus = useCallback(() => {\n    if (previousActiveElementRef.current) {\n      previousActiveElementRef.current.focus();\n    }\n  }, []);\n  \n  return {\n    trapFocus,\n    saveFocus,\n    restoreFocus\n  };\n}\n```\n\n**6. PERFORMANCE OPTIMIZATION PATTERNS**\n```typescript\n// Memoized components for performance\n// src/components/optimized/MemoizedList.tsx\ninterface ListItemProps {\n  item: any;\n  onSelect: (item: any) => void;\n  isSelected: boolean;\n}\n\nconst ListItem = React.memo<ListItemProps>(({ item, onSelect, isSelected }) => {\n  const handleClick = useCallback(() => {\n    onSelect(item);\n  }, [item, onSelect]);\n  \n  return (\n    <div \n      className={`list-item ${isSelected ? 'selected' : ''}`}\n      onClick={handleClick}\n    >\n      <h3>{item.title}</h3>\n      <p>{item.description}</p>\n    </div>\n  );\n});\n\ninterface MemoizedListProps {\n  items: any[];\n  onItemSelect: (item: any) => void;\n  selectedItem?: any;\n}\n\nexport function MemoizedList({ items, onItemSelect, selectedItem }: MemoizedListProps) {\n  // Memoize the selection handler\n  const handleItemSelect = useCallback((item: any) => {\n    onItemSelect(item);\n  }, [onItemSelect]);\n  \n  // Memoize the list rendering\n  const renderedItems = useMemo(() => {\n    return items.map(item => (\n      <ListItem\n        key={item.id}\n        item={item}\n        onSelect={handleItemSelect}\n        isSelected={selectedItem?.id === item.id}\n      />\n    ));\n  }, [items, handleItemSelect, selectedItem]);\n  \n  return (\n    <div className=\"memoized-list\">\n      {renderedItems}\n    </div>\n  );\n}\n\n// Virtual scrolling for large lists\n// src/components/optimized/VirtualList.tsx\ninterface VirtualListProps {\n  items: any[];\n  itemHeight: number;\n  containerHeight: number;\n  renderItem: (item: any, index: number) => React.ReactNode;\n}\n\nexport function VirtualList({ \n  items, \n  itemHeight, \n  containerHeight, \n  renderItem \n}: VirtualListProps) {\n  const [scrollTop, setScrollTop] = useState(0);\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  // Calculate visible range\n  const startIndex = Math.floor(scrollTop / itemHeight);\n  const endIndex = Math.min(\n    startIndex + Math.ceil(containerHeight / itemHeight) + 1,\n    items.length - 1\n  );\n  \n  // Get visible items\n  const visibleItems = items.slice(startIndex, endIndex + 1);\n  \n  // Calculate offset for positioning\n  const offsetY = startIndex * itemHeight;\n  \n  // Handle scroll\n  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {\n    setScrollTop(e.currentTarget.scrollTop);\n  }, []);\n  \n  return (\n    <div \n      ref={containerRef}\n      className=\"virtual-list-container\"\n      style={{ height: containerHeight, overflow: 'auto' }}\n      onScroll={handleScroll}\n    >\n      <div \n        className=\"virtual-list-content\"\n        style={{ height: items.length * itemHeight }}\n      >\n        <div \n          className=\"virtual-list-items\"\n          style={{ transform: `translateY(${offsetY}px)` }}\n        >\n          {visibleItems.map((item, index) => (\n            <div\n              key={startIndex + index}\n              style={{ height: itemHeight }}\n            >\n              {renderItem(item, startIndex + index)}\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n**7. COMPONENT TESTING PATTERNS**\n```typescript\n// Test utilities for components\n// src/components/__tests__/test-utils.tsx\nimport { render, RenderOptions } from '@testing-library/react';\nimport { ThemeProvider } from 'styled-components';\nimport { BrowserRouter } from 'react-router-dom';\n\n// Mock providers for testing\nconst AllTheProviders = ({ children }: { children: React.ReactNode }) => {\n  return (\n    <BrowserRouter>\n      <ThemeProvider theme={defaultTheme}>\n        {children}\n      </ThemeProvider>\n    </BrowserRouter>\n  );\n};\n\nconst customRender = (\n  ui: React.ReactElement,\n  options?: Omit<RenderOptions, 'wrapper'>\n) => render(ui, { wrapper: AllTheProviders, ...options });\n\n// Mock data generators\nexport const generateMockUser = (overrides = {}) => ({\n  id: '1',\n  name: 'John Doe',\n  email: 'john@example.com',\n  ...overrides\n});\n\nexport const generateMockCampaign = (overrides = {}) => ({\n  id: '1',\n  name: 'Test Campaign',\n  status: 'draft',\n  createdAt: new Date().toISOString(),\n  ...overrides\n});\n\n// Component test helpers\nexport const getByTestId = (container: HTMLElement, testId: string) => {\n  return container.querySelector(`[data-testid=\"${testId}\"]`);\n};\n\nexport const expectElementToBeInDocument = (element: HTMLElement | null) => {\n  expect(element).toBeInTheDocument();\n};\n\nexport const expectElementToHaveClass = (element: HTMLElement | null, className: string) => {\n  expect(element).toHaveClass(className);\n};\n\nexport * from '@testing-library/react';\nexport { customRender as render };\n\n// Example component test\n// src/components/__tests__/RsvpForm.test.tsx\ndescribe('RsvpForm', () => {\n  const mockOnSubmit = jest.fn();\n  const defaultProps = {\n    onSubmit: mockOnSubmit,\n    initialData: {}\n  };\n  \n  beforeEach(() => {\n    mockOnSubmit.mockClear();\n  });\n  \n  it('renders the form with all required fields', () => {\n    render(<RsvpForm {...defaultProps} />);\n    \n    expect(screen.getByLabelText(/first name/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/last name/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/attendance status/i)).toBeInTheDocument();\n  });\n  \n  it('validates required fields', async () => {\n    render(<RsvpForm {...defaultProps} />);\n    \n    const submitButton = screen.getByRole('button', { name: /submit/i });\n    fireEvent.click(submitButton);\n    \n    await waitFor(() => {\n      expect(screen.getByText(/first name is required/i)).toBeInTheDocument();\n      expect(screen.getByText(/email is required/i)).toBeInTheDocument();\n    });\n  });\n  \n  it('submits form with valid data', async () => {\n    render(<RsvpForm {...defaultProps} />);\n    \n    // Fill out form\n    fireEvent.change(screen.getByLabelText(/first name/i), {\n      target: { value: 'John' }\n    });\n    fireEvent.change(screen.getByLabelText(/last name/i), {\n      target: { value: 'Doe' }\n    });\n    fireEvent.change(screen.getByLabelText(/email/i), {\n      target: { value: 'john@example.com' }\n    });\n    \n    const submitButton = screen.getByRole('button', { name: /submit/i });\n    fireEvent.click(submitButton);\n    \n    await waitFor(() => {\n      expect(mockOnSubmit).toHaveBeenCalledWith({\n        firstName: 'John',\n        lastName: 'Doe',\n        email: 'john@example.com'\n      });\n    });\n  });\n});\n```\n\n**8. COMPONENT INTERCONNECTION WORKFLOW**\n```typescript\n// How components work together in the RSVP flow\n// src/components/flows/RsvpFlow.tsx\ninterface RsvpFlowProps {\n  eventId: string;\n  onComplete: (rsvpData: any) => void;\n}\n\nexport function RsvpFlow({ eventId, onComplete }: RsvpFlowProps) {\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  \n  // Step definitions with component mapping\n  const steps = [\n    {\n      id: 'contact',\n      title: 'Contact Information',\n      component: ContactInformationStep,\n      validation: validateContactInfo\n    },\n    {\n      id: 'attendance',\n      title: 'Attendance Details',\n      component: AttendanceDetailsStep,\n      validation: validateAttendanceDetails\n    },\n    {\n      id: 'preferences',\n      title: 'Preferences & Needs',\n      component: PreferencesStep,\n      validation: validatePreferences\n    },\n    {\n      id: 'confirmation',\n      title: 'Confirmation',\n      component: ConfirmationStep,\n      validation: () => true\n    }\n  ];\n  \n  // Handle step progression\n  const handleNextStep = async () => {\n    const currentStepConfig = steps[currentStep];\n    \n    // Validate current step\n    if (currentStepConfig.validation && !currentStepConfig.validation(formData)) {\n      return;\n    }\n    \n    // Move to next step\n    if (currentStep < steps.length - 1) {\n      setCurrentStep(currentStep + 1);\n    } else {\n      // Submit final form\n      await handleSubmit();\n    }\n  };\n  \n  const handleSubmit = async () => {\n    setIsSubmitting(true);\n    try {\n      const response = await fetch('/api/rsvp', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ ...formData, eventId })\n      });\n      \n      if (response.ok) {\n        const result = await response.json();\n        onComplete(result);\n      } else {\n        throw new Error('Failed to submit RSVP');\n      }\n    } catch (error) {\n      console.error('RSVP submission error:', error);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  \n  return (\n    <div className=\"rsvp-flow\">\n      {/* Progress indicator */}\n      <ProgressIndicator \n        currentStep={currentStep}\n        totalSteps={steps.length}\n        steps={steps}\n      />\n      \n      {/* Current step */}\n      <div className=\"step-container\">\n        {React.createElement(steps[currentStep].component, {\n          data: formData,\n          onChange: setFormData,\n          onSubmit: handleNextStep,\n          isSubmitting: isSubmitting\n        })}\n      </div>\n      \n      {/* Navigation */}\n      <StepNavigation\n        currentStep={currentStep}\n        totalSteps={steps.length}\n        onPrevious={() => setCurrentStep(currentStep - 1)}\n        onNext={handleNextStep}\n        isSubmitting={isSubmitting}\n      />\n    </div>\n  );\n}\n```\n\nThis comprehensive UI component system provides reusable, accessible, and performant components that work together to create a seamless user experience in the RSVP application. Each component follows established patterns for state management, validation, accessibility, and testing."}


