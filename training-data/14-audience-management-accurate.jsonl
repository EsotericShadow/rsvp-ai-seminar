{"instruction": "How does audience management work?", "input": "Explain the audience group and member management system", "output": "I'll explain the complete audience management system. Here's how audience groups and members are managed:\n\n**AUDIENCE MANAGEMENT SYSTEM**\n\n**1. AUDIENCE GROUP MODEL**\n```typescript\n// Audience Group database model\n// prisma/schema.prisma\nmodel AudienceGroup {\n  id          String             @id @default(cuid())\n  name        String\n  description String?\n  color       String?            @default(\"#10b981\")\n  criteria    Json?\n  meta        Json\n  createdAt   DateTime           @default(now())\n  updatedAt   DateTime           @updatedAt\n  members     AudienceMember[]\n  schedules   CampaignSchedule[]\n}\n```\n\n**2. AUDIENCE MEMBER MODEL**\n```typescript\n// Audience Member database model\nmodel AudienceMember {\n  id             String        @id @default(cuid())\n  groupId        String\n  businessId     String\n  businessName   String?\n  primaryEmail   String\n  secondaryEmail String?\n  tagsSnapshot   String[]\n  inviteToken    String?\n  meta           Json\n  createdAt      DateTime      @default(now())\n  unsubscribed   Boolean       @default(false)\n  group          AudienceGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)\n\n  @@unique([groupId, businessId])\n  @@index([groupId])\n  @@index([businessId])\n}\n```\n\n**3. AUDIENCE GROUP API ENDPOINTS**\n```typescript\n// Audience Group API routes\n// src/app/api/admin/campaign/groups/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { requireAdminSession } from '@/lib/adminSession';\nimport prisma from '@/lib/prisma';\n\nexport async function GET() {\n  const auth = requireAdminSession();\n  if ('response' in auth) return auth.response;\n\n  const groups = await prisma.audienceGroup.findMany({\n    include: {\n      members: true,\n      _count: {\n        select: {\n          members: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n\n  return NextResponse.json({ groups });\n}\n\nexport async function POST(request: NextRequest) {\n  const auth = requireAdminSession();\n  if ('response' in auth) return auth.response;\n\n  try {\n    const body = await request.json();\n    const { name, description, color, criteria, meta } = body;\n\n    const group = await prisma.audienceGroup.create({\n      data: {\n        name,\n        description,\n        color: color || '#10b981',\n        criteria: criteria || {},\n        meta: meta || {},\n      },\n      include: {\n        members: true,\n        _count: {\n          select: {\n            members: true,\n          },\n        },\n      },\n    });\n\n    return NextResponse.json({ group });\n  } catch (error) {\n    console.error('Error creating audience group:', error);\n    return NextResponse.json(\n      { error: 'Failed to create audience group' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n**4. AUDIENCE MEMBER MANAGEMENT**\n```typescript\n// Audience Member management functions\n// src/lib/campaigns.ts\nexport async function addAudienceMember(\n  groupId: string,\n  businessData: {\n    businessId: string;\n    businessName?: string;\n    primaryEmail: string;\n    secondaryEmail?: string;\n    tagsSnapshot?: string[];\n    inviteToken?: string;\n    meta?: any;\n  }\n) {\n  try {\n    const member = await prisma.audienceMember.create({\n      data: {\n        groupId,\n        businessId: businessData.businessId,\n        businessName: businessData.businessName,\n        primaryEmail: businessData.primaryEmail,\n        secondaryEmail: businessData.secondaryEmail,\n        tagsSnapshot: businessData.tagsSnapshot || [],\n        inviteToken: businessData.inviteToken,\n        meta: businessData.meta || {},\n      },\n    });\n\n    return member;\n  } catch (error) {\n    if (error.code === 'P2002') {\n      // Unique constraint violation - member already exists\n      throw new Error('Member already exists in this group');\n    }\n    throw error;\n  }\n}\n\nexport async function removeAudienceMember(groupId: string, businessId: string) {\n  try {\n    await prisma.audienceMember.delete({\n      where: {\n        groupId_businessId: {\n          groupId,\n          businessId,\n        },\n      },\n    });\n  } catch (error) {\n    throw new Error('Failed to remove member from group');\n  }\n}\n\nexport async function updateAudienceMember(\n  groupId: string,\n  businessId: string,\n  updateData: {\n    businessName?: string;\n    primaryEmail?: string;\n    secondaryEmail?: string;\n    tagsSnapshot?: string[];\n    inviteToken?: string;\n    meta?: any;\n    unsubscribed?: boolean;\n  }\n) {\n  try {\n    const member = await prisma.audienceMember.update({\n      where: {\n        groupId_businessId: {\n          groupId,\n          businessId,\n        },\n      },\n      data: updateData,\n    });\n\n    return member;\n  } catch (error) {\n    throw new Error('Failed to update member');\n  }\n}\n```\n\n**5. AUDIENCE GROUP CREATION**\n```typescript\n// Create audience group with criteria\nconst createAudienceGroup = async (groupData: {\n  name: string;\n  description?: string;\n  color?: string;\n  criteria?: {\n    tags?: string[];\n    location?: string;\n    industry?: string;\n    size?: string;\n  };\n  meta?: any;\n}) => {\n  const group = await prisma.audienceGroup.create({\n    data: {\n      name: groupData.name,\n      description: groupData.description,\n      color: groupData.color || '#10b981',\n      criteria: groupData.criteria || {},\n      meta: groupData.meta || {},\n    },\n  });\n\n  return group;\n};\n\n// Example usage\nconst techCompaniesGroup = await createAudienceGroup({\n  name: 'Tech Companies',\n  description: 'Technology companies in Northern BC',\n  color: '#3b82f6',\n  criteria: {\n    tags: ['technology', 'software', 'IT'],\n    location: 'Northern BC',\n    industry: 'Technology',\n    size: 'small-medium'\n  },\n  meta: {\n    createdBy: 'admin',\n    source: 'manual'\n  }\n});\n```\n\n**6. AUDIENCE MEMBER SYNC FROM LEADMINE**\n```typescript\n// Sync audience members from LeadMine\n// src/lib/campaigns.ts\nexport async function syncAudienceFromLeadMine(\n  groupId: string,\n  leadMineData: LeadMineBusiness[]\n) {\n  const results = {\n    added: 0,\n    updated: 0,\n    errors: 0,\n    errors: [] as string[]\n  };\n\n  for (const business of leadMineData) {\n    try {\n      // Check if member already exists\n      const existingMember = await prisma.audienceMember.findUnique({\n        where: {\n          groupId_businessId: {\n            groupId,\n            businessId: business.id,\n          },\n        },\n      });\n\n      if (existingMember) {\n        // Update existing member\n        await prisma.audienceMember.update({\n          where: {\n            groupId_businessId: {\n              groupId,\n              businessId: business.id,\n            },\n          },\n          data: {\n            businessName: business.name,\n            primaryEmail: business.contact.primaryEmail,\n            secondaryEmail: business.contact.alternateEmail,\n            tagsSnapshot: business.contact.tags,\n            inviteToken: business.invite?.token,\n            meta: {\n              ...existingMember.meta,\n              lastSynced: new Date().toISOString(),\n              leadMineData: {\n                status: business.lead.status,\n                priority: business.lead.priority,\n                assignedTo: business.lead.assignedTo,\n                nextFollowUpDate: business.lead.nextFollowUpDate,\n              },\n            },\n          },\n        });\n        results.updated++;\n      } else {\n        // Create new member\n        await prisma.audienceMember.create({\n          data: {\n            groupId,\n            businessId: business.id,\n            businessName: business.name,\n            primaryEmail: business.contact.primaryEmail,\n            secondaryEmail: business.contact.alternateEmail,\n            tagsSnapshot: business.contact.tags,\n            inviteToken: business.invite?.token,\n            meta: {\n              lastSynced: new Date().toISOString(),\n              leadMineData: {\n                status: business.lead.status,\n                priority: business.lead.priority,\n                assignedTo: business.lead.assignedTo,\n                nextFollowUpDate: business.lead.nextFollowUpDate,\n              },\n            },\n          },\n        });\n        results.added++;\n      }\n    } catch (error) {\n      results.errors++;\n      results.errors.push(`Failed to sync business ${business.id}: ${error.message}`);\n    }\n  }\n\n  return results;\n}\n```\n\n**7. AUDIENCE SEGMENTATION**\n```typescript\n// Audience segmentation based on criteria\nconst segmentAudience = async (groupId: string, criteria: {\n  tags?: string[];\n  location?: string;\n  industry?: string;\n  size?: string;\n  unsubscribed?: boolean;\n}) => {\n  const whereClause: any = {\n    groupId,\n  };\n\n  if (criteria.tags && criteria.tags.length > 0) {\n    whereClause.tagsSnapshot = {\n      hasSome: criteria.tags,\n    };\n  }\n\n  if (criteria.unsubscribed !== undefined) {\n    whereClause.unsubscribed = criteria.unsubscribed;\n  }\n\n  // Add more criteria based on meta fields\n  if (criteria.location) {\n    whereClause.meta = {\n      path: ['location'],\n      equals: criteria.location,\n    };\n  }\n\n  const members = await prisma.audienceMember.findMany({\n    where: whereClause,\n    include: {\n      group: true,\n    },\n  });\n\n  return members;\n};\n\n// Example segmentation\nconst techMembers = await segmentAudience('tech-group-id', {\n  tags: ['technology', 'software'],\n  location: 'Northern BC',\n  unsubscribed: false,\n});\n```\n\n**8. AUDIENCE ANALYTICS**\n```typescript\n// Audience analytics and reporting\nconst getAudienceAnalytics = async (groupId: string) => {\n  const group = await prisma.audienceGroup.findUnique({\n    where: { id: groupId },\n    include: {\n      members: {\n        include: {\n          // Include campaign sends for engagement metrics\n          group: {\n            include: {\n              schedules: {\n                include: {\n                  sends: true,\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (!group) {\n    throw new Error('Group not found');\n  }\n\n  const analytics = {\n    totalMembers: group.members.length,\n    activeMembers: group.members.filter(m => !m.unsubscribed).length,\n    unsubscribedMembers: group.members.filter(m => m.unsubscribed).length,\n    \n    // Engagement metrics\n    totalEmailsSent: group.members.reduce((sum, member) => {\n      return sum + (member.group?.schedules?.reduce((scheduleSum, schedule) => {\n        return scheduleSum + schedule.sends.length;\n      }, 0) || 0);\n    }, 0),\n    \n    // Tag distribution\n    tagDistribution: group.members.reduce((acc, member) => {\n      member.tagsSnapshot.forEach(tag => {\n        acc[tag] = (acc[tag] || 0) + 1;\n      });\n      return acc;\n    }, {} as Record<string, number>),\n    \n    // Recent activity\n    recentActivity: group.members\n      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())\n      .slice(0, 10),\n  };\n\n  return analytics;\n};\n```\n\n**9. AUDIENCE MEMBER BULK OPERATIONS**\n```typescript\n// Bulk operations for audience members\nconst bulkUpdateAudienceMembers = async (\n  groupId: string,\n  updates: Array<{\n    businessId: string;\n    updateData: any;\n  }>\n) => {\n  const results = {\n    updated: 0,\n    errors: 0,\n    errors: [] as string[]\n  };\n\n  for (const update of updates) {\n    try {\n      await prisma.audienceMember.update({\n        where: {\n          groupId_businessId: {\n            groupId,\n            businessId: update.businessId,\n          },\n        },\n        data: update.updateData,\n      });\n      results.updated++;\n    } catch (error) {\n      results.errors++;\n      results.errors.push(`Failed to update ${update.businessId}: ${error.message}`);\n    }\n  }\n\n  return results;\n};\n\n// Bulk unsubscribe\nconst bulkUnsubscribe = async (groupId: string, businessIds: string[]) => {\n  const result = await prisma.audienceMember.updateMany({\n    where: {\n      groupId,\n      businessId: {\n        in: businessIds,\n      },\n    },\n    data: {\n      unsubscribed: true,\n      meta: {\n        unsubscribedAt: new Date().toISOString(),\n        unsubscribedBy: 'bulk-operation',\n      },\n    },\n  });\n\n  return result;\n};\n```\n\n**10. AUDIENCE GROUP UI COMPONENTS**\n```typescript\n// Audience Group management UI\n// src/components/admin/campaign/AudienceGroups.tsx\nexport default function AudienceGroups({ groups, onGroupSelect }) {\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <h3 className=\"text-lg font-semibold\">Audience Groups</h3>\n        <button \n          onClick={() => setShowCreateGroup(true)}\n          className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700\"\n        >\n          Create Group\n        </button>\n      </div>\n      \n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n        {groups.map((group) => (\n          <div \n            key={group.id}\n            className=\"p-4 border rounded-lg hover:shadow-md cursor-pointer\"\n            onClick={() => onGroupSelect(group)}\n          >\n            <div className=\"flex items-center justify-between mb-2\">\n              <h4 className=\"font-medium\">{group.name}</h4>\n              <div \n                className=\"w-3 h-3 rounded-full\"\n                style={{ backgroundColor: group.color }}\n              />\n            </div>\n            <p className=\"text-sm text-gray-600 mb-2\">{group.description}</p>\n            <div className=\"text-sm text-gray-500\">\n              {group._count.members} members\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n\nThis audience management system provides comprehensive functionality for creating, managing, and segmenting audience groups and members, with integration to LeadMine for business data synchronization."}


