{"instruction": "How does middleware work?", "input": "Explain cookie management and UTM tracking middleware", "output": "I'll explain the complete middleware system. Here's how cookie management and UTM tracking work:\n\n**MIDDLEWARE FEATURES SYSTEM**\n\n**1. MIDDLEWARE CONFIGURATION**\n```typescript\n// Next.js middleware configuration\n// middleware.ts\nimport type { NextRequest } from 'next/server';\nimport { NextResponse } from 'next/server';\n\nconst SESSION_MS = 30 * 60 * 1000; // 30 minutes\n\nexport function middleware(req: NextRequest) {\n  const res = NextResponse.next();\n  const url = req.nextUrl;\n\n  // 1) Visitor ID (2 years)\n  let vid = req.cookies.get('vid')?.value;\n  if (!vid) {\n    vid = crypto.randomUUID();\n    res.cookies.set('vid', vid, {\n      path: '/',\n      httpOnly: true,\n      sameSite: 'lax',\n      secure: true,\n      maxAge: 60 * 60 * 24 * 365 * 2, // 2 years\n    });\n  }\n\n  // 2) Session ID (30-min rolling)\n  const now = Date.now();\n  let sid = req.cookies.get('sid')?.value;\n  const sidTs = Number(req.cookies.get('sid_ts')?.value || 0);\n  if (!sid || now - sidTs > SESSION_MS) {\n    sid = crypto.randomUUID();\n    res.cookies.set('sid', sid, { \n      path: '/', \n      httpOnly: true, \n      sameSite: 'lax', \n      secure: true, \n      maxAge: 60 * 60 * 24 \n    });\n    res.cookies.set('sid_ts', String(now), { \n      path: '/', \n      httpOnly: true, \n      sameSite: 'lax', \n      secure: true, \n      maxAge: 60 * 60 * 24 \n    });\n  } else {\n    res.cookies.set('sid_ts', String(now), { \n      path: '/', \n      httpOnly: true, \n      sameSite: 'lax', \n      secure: true, \n      maxAge: 60 * 60 * 24 \n    });\n  }\n\n  // 3) Persist UTM/eid/click IDs (90 days)\n  const sp = url.searchParams;\n  const utmKeys = [\n    'utm_source', 'utm_medium', 'utm_campaign', \n    'utm_term', 'utm_content', 'eid',\n    'gclid', 'fbclid', 'msclkid'\n  ];\n  \n  for (const k of utmKeys) {\n    const v = sp.get(k);\n    if (v) {\n      res.cookies.set(k, v, {\n        path: '/',\n        httpOnly: true,\n        sameSite: 'lax',\n        secure: true,\n        maxAge: 60 * 60 * 24 * 90, // 90 days\n      });\n    }\n  }\n\n  return res;\n}\n\nexport const config = {\n  matcher: ['/((?!_next/static|_next/image|favicon.ico|api/__pixel).*)']\n};\n```\n\n**2. COOKIE MANAGEMENT UTILITIES**\n```typescript\n// Cookie management utilities\n// src/lib/cookies.ts\nexport class CookieManager {\n  private static instance: CookieManager;\n  \n  static getInstance(): CookieManager {\n    if (!CookieManager.instance) {\n      CookieManager.instance = new CookieManager();\n    }\n    return CookieManager.instance;\n  }\n  \n  // Set cookie with security defaults\n  setCookie(\n    name: string,\n    value: string,\n    options: {\n      maxAge?: number;\n      httpOnly?: boolean;\n      secure?: boolean;\n      sameSite?: 'strict' | 'lax' | 'none';\n      path?: string;\n    } = {}\n  ) {\n    const defaults = {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax' as const,\n      path: '/',\n      maxAge: 60 * 60 * 24 * 30 // 30 days\n    };\n    \n    const config = { ...defaults, ...options };\n    \n    return {\n      name,\n      value,\n      ...config\n    };\n  }\n  \n  // Get cookie value\n  getCookie(name: string, cookies: any): string | undefined {\n    return cookies.get(name)?.value;\n  }\n  \n  // Delete cookie\n  deleteCookie(name: string) {\n    return {\n      name,\n      value: '',\n      maxAge: 0,\n      path: '/'\n    };\n  }\n  \n  // Check if cookie exists\n  hasCookie(name: string, cookies: any): boolean {\n    return cookies.has(name);\n  }\n}\n\n// UTM parameter management\nexport class UTMManager {\n  private static instance: UTMManager;\n  \n  static getInstance(): UTMManager {\n    if (!UTMManager.instance) {\n      UTMManager.instance = new UTMManager();\n    }\n    return UTMManager.instance;\n  }\n  \n  // Extract UTM parameters from URL\n  extractUTMParams(url: URL): Record<string, string> {\n    const utmParams: Record<string, string> = {};\n    const utmKeys = [\n      'utm_source', 'utm_medium', 'utm_campaign',\n      'utm_term', 'utm_content', 'eid',\n      'gclid', 'fbclid', 'msclkid'\n    ];\n    \n    for (const key of utmKeys) {\n      const value = url.searchParams.get(key);\n      if (value) {\n        utmParams[key] = value;\n      }\n    }\n    \n    return utmParams;\n  }\n  \n  // Get UTM parameters from cookies\n  getUTMFromCookies(cookies: any): Record<string, string> {\n    const utmParams: Record<string, string> = {};\n    const utmKeys = [\n      'utm_source', 'utm_medium', 'utm_campaign',\n      'utm_term', 'utm_content', 'eid',\n      'gclid', 'fbclid', 'msclkid'\n    ];\n    \n    for (const key of utmKeys) {\n      const value = cookies.get(key)?.value;\n      if (value) {\n        utmParams[key] = value;\n      }\n    }\n    \n    return utmParams;\n  }\n  \n  // Validate UTM parameters\n  validateUTMParams(params: Record<string, string>): {\n    valid: boolean;\n    errors: string[];\n  } {\n    const errors: string[] = [];\n    \n    // Check for required UTM parameters\n    if (params.utm_source && !params.utm_medium) {\n      errors.push('utm_medium is required when utm_source is provided');\n    }\n    \n    // Validate UTM source\n    if (params.utm_source) {\n      const validSources = ['google', 'facebook', 'twitter', 'linkedin', 'email', 'direct'];\n      if (!validSources.includes(params.utm_source.toLowerCase())) {\n        errors.push('Invalid utm_source value');\n      }\n    }\n    \n    // Validate UTM medium\n    if (params.utm_medium) {\n      const validMediums = ['cpc', 'cpm', 'email', 'social', 'organic', 'referral'];\n      if (!validMediums.includes(params.utm_medium.toLowerCase())) {\n        errors.push('Invalid utm_medium value');\n      }\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n}\n```\n\n**3. VISITOR TRACKING**\n```typescript\n// Visitor tracking and session management\n// src/lib/visitor-tracking.ts\nexport class VisitorTracker {\n  private static instance: VisitorTracker;\n  \n  static getInstance(): VisitorTracker {\n    if (!VisitorTracker.instance) {\n      VisitorTracker.instance = new VisitorTracker();\n    }\n    return VisitorTracker.instance;\n  }\n  \n  // Generate visitor ID\n  generateVisitorId(): string {\n    return crypto.randomUUID();\n  }\n  \n  // Generate session ID\n  generateSessionId(): string {\n    return crypto.randomUUID();\n  }\n  \n  // Check if session is expired\n  isSessionExpired(sessionTimestamp: number): boolean {\n    const now = Date.now();\n    const sessionAge = now - sessionTimestamp;\n    return sessionAge > SESSION_MS;\n  }\n  \n  // Get visitor fingerprint\n  getVisitorFingerprint(req: NextRequest): string {\n    const userAgent = req.headers.get('user-agent') || '';\n    const acceptLanguage = req.headers.get('accept-language') || '';\n    const acceptEncoding = req.headers.get('accept-encoding') || '';\n    const ip = req.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\n    \n    const fingerprint = `${userAgent}-${acceptLanguage}-${acceptEncoding}-${ip}`;\n    return crypto.createHash('sha256').update(fingerprint).digest('hex');\n  }\n  \n  // Track page visit\n  async trackPageVisit(\n    req: NextRequest,\n    path: string,\n    query: string\n  ): Promise<void> {\n    try {\n      const visitorId = req.cookies.get('vid')?.value;\n      const sessionId = req.cookies.get('sid')?.value;\n      \n      if (!visitorId || !sessionId) {\n        return; // Skip tracking if no visitor/session ID\n      }\n      \n      const utmParams = UTMManager.getInstance().getUTMFromCookies(req.cookies);\n      const fingerprint = this.getVisitorFingerprint(req);\n      \n      await prisma.visit.create({\n        data: {\n          visitorId,\n          sessionId,\n          path,\n          query,\n          referrer: req.headers.get('referer'),\n          ...utmParams,\n          userAgent: req.headers.get('user-agent'),\n          language: req.headers.get('accept-language'),\n          country: req.headers.get('x-vercel-ip-country'),\n          region: req.headers.get('x-vercel-ip-country-region'),\n          city: req.headers.get('x-vercel-ip-city'),\n          ipHash: crypto.createHash('sha256').update(\n            req.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown'\n          ).digest('hex'),\n          meta: JSON.stringify({\n            fingerprint,\n            timestamp: new Date().toISOString()\n          })\n        }\n      });\n    } catch (error) {\n      console.error('Visitor tracking error:', error);\n    }\n  }\n}\n```\n\n**4. LINK TRACKING MIDDLEWARE**\n```typescript\n// Link tracking for campaign attribution\n// src/app/api/l/route.ts\nexport async function GET(req: Request) {\n  const url = new URL(req.url);\n  const to = url.searchParams.get('to');\n  if (!to) return NextResponse.json({ error: 'Missing \"to\" param' }, { status: 400 });\n\n  const c = cookies();\n  const h = (k: string) => headers().get(k);\n  const vid = c.get('vid')?.value ?? 'unknown';\n  const sid = c.get('sid')?.value ?? 'unknown';\n\n  // Prefer explicit eid in the link; fallback to cookie\n  const eid = url.searchParams.get('eid') ?? c.get('eid')?.value ?? undefined;\n\n  // Get UTM parameters from cookies\n  const utmSource = c.get('utm_source')?.value;\n  const utmMedium = c.get('utm_medium')?.value;\n  const utmCampaign = c.get('utm_campaign')?.value;\n  const utmTerm = c.get('utm_term')?.value;\n  const utmContent = c.get('utm_content')?.value;\n\n  // Parse user agent\n  const ua = h('user-agent') || undefined;\n  const parsed = ua ? new UAParser(ua).getResult() : undefined;\n  const browser = parsed?.browser?.name;\n  const device = parsed?.device?.type || 'desktop';\n  const platform = parsed?.os?.name;\n\n  // Get geolocation\n  const referer = h('referer') || undefined;\n  const country = h('x-vercel-ip-country') || undefined;\n  const region = h('x-vercel-ip-country-region') || undefined;\n  const city = h('x-vercel-ip-city') || undefined;\n  const ip = h('x-forwarded-for')?.split(',')[0]?.trim();\n  const ipHash = ip ? crypto.createHash('sha256').update(ip).digest('hex') : undefined;\n\n  // Track the link click\n  try {\n    await prisma.visit.create({\n      data: {\n        visitorId: vid,\n        sessionId: sid,\n        path: '/api/l',\n        query: url.search,\n        referrer: referer,\n        eid, utmSource, utmMedium, utmCampaign, utmTerm, utmContent,\n        userAgent: ua, browser, device, platform,\n        country, region, city, ipHash,\n      },\n    });\n  } catch {\n    // Stay silent on errors\n  }\n\n  return NextResponse.redirect(to, { status: 302 });\n}\n```\n\n**5. SECURITY HEADERS MIDDLEWARE**\n```typescript\n// Security headers middleware\n// src/lib/security-middleware.ts\nexport function addSecurityHeaders(res: NextResponse): NextResponse {\n  // Security headers\n  res.headers.set('X-Content-Type-Options', 'nosniff');\n  res.headers.set('X-Frame-Options', 'DENY');\n  res.headers.set('X-XSS-Protection', '1; mode=block');\n  res.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');\n  res.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');\n  \n  // Content Security Policy\n  res.headers.set(\n    'Content-Security-Policy',\n    [\n      \"default-src 'self'\",\n      \"script-src 'self' 'unsafe-inline' 'unsafe-eval' https://vercel.live\",\n      \"style-src 'self' 'unsafe-inline'\",\n      \"img-src 'self' data: https: blob:\",\n      \"font-src 'self' data:\",\n      \"connect-src 'self' https://api.lead-mine.vercel.app https://api.resend.com https://api.sendgrid.com\",\n      \"frame-src 'none'\",\n      \"object-src 'none'\",\n      \"base-uri 'self'\",\n      \"form-action 'self'\",\n      \"frame-ancestors 'none'\"\n    ].join('; ')\n  );\n  \n  return res;\n}\n\n// Admin route protection middleware\nexport function protectAdminRoutes(req: NextRequest): NextResponse | null {\n  if (req.nextUrl.pathname.startsWith('/admin')) {\n    const token = req.cookies.get(getSessionCookieName())?.value;\n    const config = getAdminConfig();\n    \n    if (!config) {\n      return NextResponse.redirect(new URL('/admin/login?error=config', req.url));\n    }\n    \n    const session = verifySessionToken(token, config.sessionSecret);\n    if (!session) {\n      const loginUrl = new URL('/admin/login', req.url);\n      loginUrl.searchParams.set('next', req.nextUrl.pathname);\n      return NextResponse.redirect(loginUrl);\n    }\n  }\n  \n  return null;\n}\n```\n\n**6. RATE LIMITING MIDDLEWARE**\n```typescript\n// Rate limiting middleware\n// src/lib/rate-limiting.ts\nexport class RateLimiter {\n  private static instance: RateLimiter;\n  private limits: Map<string, { count: number; resetTime: number }> = new Map();\n  \n  static getInstance(): RateLimiter {\n    if (!RateLimiter.instance) {\n      RateLimiter.instance = new RateLimiter();\n    }\n    return RateLimiter.instance;\n  }\n  \n  // Check rate limit\n  checkRateLimit(\n    key: string,\n    maxRequests: number,\n    windowMs: number\n  ): { allowed: boolean; remaining: number; resetTime: number } {\n    const now = Date.now();\n    const limit = this.limits.get(key);\n    \n    if (!limit || now > limit.resetTime) {\n      // Create new limit\n      this.limits.set(key, {\n        count: 1,\n        resetTime: now + windowMs\n      });\n      \n      return {\n        allowed: true,\n        remaining: maxRequests - 1,\n        resetTime: now + windowMs\n      };\n    }\n    \n    if (limit.count >= maxRequests) {\n      return {\n        allowed: false,\n        remaining: 0,\n        resetTime: limit.resetTime\n      };\n    }\n    \n    // Increment count\n    limit.count++;\n    this.limits.set(key, limit);\n    \n    return {\n      allowed: true,\n      remaining: maxRequests - limit.count,\n      resetTime: limit.resetTime\n    };\n  }\n  \n  // Clean up expired limits\n  cleanupExpiredLimits(): void {\n    const now = Date.now();\n    for (const [key, limit] of this.limits) {\n      if (now > limit.resetTime) {\n        this.limits.delete(key);\n      }\n    }\n  }\n}\n\n// Rate limiting for RSVP submissions\nexport function checkRSVPRateLimit(\n  clientIP: string,\n  userAgent: string,\n  acceptLanguage: string,\n  acceptEncoding: string\n): { allowed: boolean; remaining: number; resetTime: number } {\n  const fingerprint = crypto\n    .createHash('sha256')\n    .update(`${clientIP}-${userAgent}-${acceptLanguage}-${acceptEncoding}`)\n    .digest('hex');\n  \n  const rateLimiter = RateLimiter.getInstance();\n  return rateLimiter.checkRateLimit(\n    `rsvp:${fingerprint}`,\n    5, // 5 requests\n    60 * 60 * 1000 // 1 hour\n  );\n}\n```\n\n**7. MIDDLEWARE INTEGRATION**\n```typescript\n// Complete middleware integration\n// middleware.ts\nexport function middleware(req: NextRequest) {\n  const res = NextResponse.next();\n  \n  // Add security headers\n  addSecurityHeaders(res);\n  \n  // Check admin route protection\n  const adminProtection = protectAdminRoutes(req);\n  if (adminProtection) {\n    return adminProtection;\n  }\n  \n  // Rate limiting for API routes\n  if (req.nextUrl.pathname.startsWith('/api/')) {\n    const clientIP = req.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\n    const userAgent = req.headers.get('user-agent') || '';\n    const acceptLanguage = req.headers.get('accept-language') || '';\n    const acceptEncoding = req.headers.get('accept-encoding') || '';\n    \n    const rateLimit = checkRSVPRateLimit(clientIP, userAgent, acceptLanguage, acceptEncoding);\n    if (!rateLimit.allowed) {\n      return NextResponse.json(\n        { error: 'Rate limit exceeded' },\n        { status: 429 }\n      );\n    }\n  }\n  \n  // Visitor and session management\n  const url = req.nextUrl;\n  \n  // Visitor ID management\n  let vid = req.cookies.get('vid')?.value;\n  if (!vid) {\n    vid = crypto.randomUUID();\n    res.cookies.set('vid', vid, {\n      path: '/',\n      httpOnly: true,\n      sameSite: 'lax',\n      secure: true,\n      maxAge: 60 * 60 * 24 * 365 * 2, // 2 years\n    });\n  }\n\n  // Session ID management\n  const now = Date.now();\n  let sid = req.cookies.get('sid')?.value;\n  const sidTs = Number(req.cookies.get('sid_ts')?.value || 0);\n  if (!sid || now - sidTs > SESSION_MS) {\n    sid = crypto.randomUUID();\n    res.cookies.set('sid', sid, { \n      path: '/', \n      httpOnly: true, \n      sameSite: 'lax', \n      secure: true, \n      maxAge: 60 * 60 * 24 \n    });\n    res.cookies.set('sid_ts', String(now), { \n      path: '/', \n      httpOnly: true, \n      sameSite: 'lax', \n      secure: true, \n      maxAge: 60 * 60 * 24 \n    });\n  } else {\n    res.cookies.set('sid_ts', String(now), { \n      path: '/', \n      httpOnly: true, \n      sameSite: 'lax', \n      secure: true, \n      maxAge: 60 * 60 * 24 \n    });\n  }\n\n  // UTM parameter persistence\n  const sp = url.searchParams;\n  const utmKeys = [\n    'utm_source', 'utm_medium', 'utm_campaign', \n    'utm_term', 'utm_content', 'eid',\n    'gclid', 'fbclid', 'msclkid'\n  ];\n  \n  for (const k of utmKeys) {\n    const v = sp.get(k);\n    if (v) {\n      res.cookies.set(k, v, {\n        path: '/',\n        httpOnly: true,\n        sameSite: 'lax',\n        secure: true,\n        maxAge: 60 * 60 * 24 * 90, // 90 days\n      });\n    }\n  }\n\n  return res;\n}\n```\n\nThis comprehensive middleware system provides cookie management, UTM tracking, visitor identification, security headers, rate limiting, and admin route protection for your RSVP application."}


