{"instruction": "How does error handling work in this application?", "input": "Explain the complete error handling system including logging, user feedback, monitoring, and recovery patterns", "output": "I'll explain the comprehensive error handling system. Here's how errors are managed, logged, and handled throughout the application:\n\n**ERROR HANDLING ARCHITECTURE**\n\n**1. ERROR CLASSIFICATION SYSTEM**\n```typescript\n// Error types and classification\n// src/lib/errors/error-types.ts\n\nexport enum ErrorType {\n  VALIDATION = 'VALIDATION',\n  AUTHENTICATION = 'AUTHENTICATION',\n  AUTHORIZATION = 'AUTHORIZATION',\n  NOT_FOUND = 'NOT_FOUND',\n  CONFLICT = 'CONFLICT',\n  RATE_LIMIT = 'RATE_LIMIT',\n  EXTERNAL_SERVICE = 'EXTERNAL_SERVICE',\n  DATABASE = 'DATABASE',\n  NETWORK = 'NETWORK',\n  INTERNAL = 'INTERNAL'\n}\n\nexport enum ErrorSeverity {\n  LOW = 'LOW',\n  MEDIUM = 'MEDIUM',\n  HIGH = 'HIGH',\n  CRITICAL = 'CRITICAL'\n}\n\nexport interface ErrorContext {\n  userId?: string;\n  sessionId?: string;\n  requestId?: string;\n  endpoint?: string;\n  method?: string;\n  userAgent?: string;\n  ipAddress?: string;\n  timestamp: Date;\n  metadata?: Record<string, any>;\n}\n\nexport class ApplicationError extends Error {\n  public readonly type: ErrorType;\n  public readonly severity: ErrorSeverity;\n  public readonly context: ErrorContext;\n  public readonly isOperational: boolean;\n  public readonly statusCode: number;\n  \n  constructor(\n    message: string,\n    type: ErrorType,\n    severity: ErrorSeverity = ErrorSeverity.MEDIUM,\n    statusCode: number = 500,\n    isOperational: boolean = true,\n    context?: Partial<ErrorContext>\n  ) {\n    super(message);\n    \n    this.name = this.constructor.name;\n    this.type = type;\n    this.severity = severity;\n    this.statusCode = statusCode;\n    this.isOperational = isOperational;\n    this.context = {\n      timestamp: new Date(),\n      ...context\n    };\n    \n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n// Specific error classes\nexport class ValidationError extends ApplicationError {\n  public readonly fieldErrors: Record<string, string>;\n  \n  constructor(message: string, fieldErrors: Record<string, string>, context?: Partial<ErrorContext>) {\n    super(message, ErrorType.VALIDATION, ErrorSeverity.LOW, 400, true, context);\n    this.fieldErrors = fieldErrors;\n  }\n}\n\nexport class AuthenticationError extends ApplicationError {\n  constructor(message: string = 'Authentication required', context?: Partial<ErrorContext>) {\n    super(message, ErrorType.AUTHENTICATION, ErrorSeverity.MEDIUM, 401, true, context);\n  }\n}\n\nexport class AuthorizationError extends ApplicationError {\n  constructor(message: string = 'Access denied', context?: Partial<ErrorContext>) {\n    super(message, ErrorType.AUTHORIZATION, ErrorSeverity.MEDIUM, 403, true, context);\n  }\n}\n\nexport class NotFoundError extends ApplicationError {\n  constructor(resource: string, context?: Partial<ErrorContext>) {\n    super(`${resource} not found`, ErrorType.NOT_FOUND, ErrorSeverity.LOW, 404, true, context);\n  }\n}\n\nexport class ConflictError extends ApplicationError {\n  constructor(message: string, context?: Partial<ErrorContext>) {\n    super(message, ErrorType.CONFLICT, ErrorSeverity.MEDIUM, 409, true, context);\n  }\n}\n\nexport class RateLimitError extends ApplicationError {\n  constructor(message: string = 'Rate limit exceeded', context?: Partial<ErrorContext>) {\n    super(message, ErrorType.RATE_LIMIT, ErrorSeverity.MEDIUM, 429, true, context);\n  }\n}\n\nexport class ExternalServiceError extends ApplicationError {\n  public readonly service: string;\n  \n  constructor(service: string, message: string, context?: Partial<ErrorContext>) {\n    super(`External service error (${service}): ${message}`, ErrorType.EXTERNAL_SERVICE, ErrorSeverity.HIGH, 502, true, context);\n    this.service = service;\n  }\n}\n\nexport class DatabaseError extends ApplicationError {\n  public readonly operation: string;\n  \n  constructor(operation: string, message: string, context?: Partial<ErrorContext>) {\n    super(`Database error (${operation}): ${message}`, ErrorType.DATABASE, ErrorSeverity.HIGH, 500, true, context);\n    this.operation = operation;\n  }\n}\n```\n\n**2. ERROR LOGGING SYSTEM**\n```typescript\n// Comprehensive error logging\n// src/lib/errors/error-logger.ts\nimport { ApplicationError, ErrorSeverity } from './error-types';\n\nexport interface LogEntry {\n  id: string;\n  timestamp: Date;\n  level: 'error' | 'warn' | 'info' | 'debug';\n  message: string;\n  error?: {\n    name: string;\n    message: string;\n    stack?: string;\n    type: string;\n    severity: string;\n    context: any;\n  };\n  request?: {\n    method: string;\n    url: string;\n    userAgent: string;\n    ip: string;\n    userId?: string;\n  };\n  metadata?: Record<string, any>;\n}\n\nexport class ErrorLogger {\n  private static instance: ErrorLogger;\n  private logs: LogEntry[] = [];\n  private maxLogs: number = 10000;\n  \n  static getInstance(): ErrorLogger {\n    if (!ErrorLogger.instance) {\n      ErrorLogger.instance = new ErrorLogger();\n    }\n    return ErrorLogger.instance;\n  }\n  \n  logError(error: Error, context?: any): void {\n    const logEntry: LogEntry = {\n      id: this.generateId(),\n      timestamp: new Date(),\n      level: 'error',\n      message: error.message,\n      error: {\n        name: error.name,\n        message: error.message,\n        stack: error.stack,\n        ...(error instanceof ApplicationError && {\n          type: error.type,\n          severity: error.severity,\n          context: error.context\n        })\n      },\n      metadata: context\n    };\n    \n    this.addLog(logEntry);\n    this.outputToConsole(logEntry);\n    this.sendToMonitoring(logEntry);\n  }\n  \n  logWarning(message: string, context?: any): void {\n    const logEntry: LogEntry = {\n      id: this.generateId(),\n      timestamp: new Date(),\n      level: 'warn',\n      message,\n      metadata: context\n    };\n    \n    this.addLog(logEntry);\n    this.outputToConsole(logEntry);\n  }\n  \n  logInfo(message: string, context?: any): void {\n    const logEntry: LogEntry = {\n      id: this.generateId(),\n      timestamp: new Date(),\n      level: 'info',\n      message,\n      metadata: context\n    };\n    \n    this.addLog(logEntry);\n    \n    if (process.env.NODE_ENV === 'development') {\n      this.outputToConsole(logEntry);\n    }\n  }\n  \n  private addLog(logEntry: LogEntry): void {\n    this.logs.unshift(logEntry);\n    \n    // Keep only the most recent logs\n    if (this.logs.length > this.maxLogs) {\n      this.logs = this.logs.slice(0, this.maxLogs);\n    }\n  }\n  \n  private outputToConsole(logEntry: LogEntry): void {\n    const timestamp = logEntry.timestamp.toISOString();\n    const level = logEntry.level.toUpperCase().padEnd(5);\n    const message = logEntry.message;\n    \n    const logMessage = `[${timestamp}] ${level} ${message}`;\n    \n    switch (logEntry.level) {\n      case 'error':\n        console.error(logMessage, logEntry.error || logEntry.metadata);\n        break;\n      case 'warn':\n        console.warn(logMessage, logEntry.metadata);\n        break;\n      case 'info':\n        console.info(logMessage, logEntry.metadata);\n        break;\n      case 'debug':\n        console.debug(logMessage, logEntry.metadata);\n        break;\n    }\n  }\n  \n  private sendToMonitoring(logEntry: LogEntry): void {\n    // Send to monitoring service in production\n    if (process.env.NODE_ENV === 'production') {\n      // This could integrate with services like:\n      // - Sentry for error tracking\n      // - Datadog for monitoring\n      // - LogRocket for session replay\n      // - Custom monitoring endpoint\n      \n      this.sendToSentry(logEntry);\n      this.sendToDatadog(logEntry);\n    }\n  }\n  \n  private sendToSentry(logEntry: LogEntry): void {\n    // Sentry integration\n    if (process.env.SENTRY_DSN) {\n      // Sentry.captureException(logEntry.error, {\n      //   tags: {\n      //     type: logEntry.error?.type,\n      //     severity: logEntry.error?.severity\n      //   },\n      //   extra: logEntry.metadata\n      // });\n    }\n  }\n  \n  private sendToDatadog(logEntry: LogEntry): void {\n    // Datadog integration\n    if (process.env.DATADOG_API_KEY) {\n      // Send metrics and logs to Datadog\n    }\n  }\n  \n  private generateId(): string {\n    return Math.random().toString(36).substring(2, 15);\n  }\n  \n  getLogs(filter?: { level?: string; since?: Date; limit?: number }): LogEntry[] {\n    let filteredLogs = this.logs;\n    \n    if (filter?.level) {\n      filteredLogs = filteredLogs.filter(log => log.level === filter.level);\n    }\n    \n    if (filter?.since) {\n      filteredLogs = filteredLogs.filter(log => log.timestamp >= filter.since!);\n    }\n    \n    if (filter?.limit) {\n      filteredLogs = filteredLogs.slice(0, filter.limit);\n    }\n    \n    return filteredLogs;\n  }\n  \n  clearLogs(): void {\n    this.logs = [];\n  }\n}\n\nexport const errorLogger = ErrorLogger.getInstance();\n```\n\n**3. ERROR HANDLING MIDDLEWARE**\n```typescript\n// Global error handling middleware\n// src/lib/errors/error-handler.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { ApplicationError, ErrorType, ErrorSeverity } from './error-types';\nimport { errorLogger } from './error-logger';\nimport { ValidationError, AuthenticationError, AuthorizationError, NotFoundError, ConflictError, RateLimitError, ExternalServiceError, DatabaseError } from './error-types';\n\nexport function handleError(error: any, request?: NextRequest): NextResponse {\n  // Log the error\n  errorLogger.logError(error, {\n    request: request ? {\n      method: request.method,\n      url: request.url,\n      userAgent: request.headers.get('user-agent') || '',\n      ip: request.headers.get('x-forwarded-for')?.split(',')[0] || 'unknown'\n    } : undefined\n  });\n  \n  // Handle known error types\n  if (error instanceof ValidationError) {\n    return createValidationErrorResponse(error.fieldErrors, error.context);\n  }\n  \n  if (error instanceof AuthenticationError) {\n    return createAuthenticationErrorResponse(error.context);\n  }\n  \n  if (error instanceof AuthorizationError) {\n    return createAuthorizationErrorResponse(error.context);\n  }\n  \n  if (error instanceof NotFoundError) {\n    return createNotFoundErrorResponse(error.message, error.context);\n  }\n  \n  if (error instanceof ConflictError) {\n    return createConflictErrorResponse(error.message, error.context);\n  }\n  \n  if (error instanceof RateLimitError) {\n    return createRateLimitErrorResponse(error.context);\n  }\n  \n  if (error instanceof ExternalServiceError) {\n    return createExternalServiceErrorResponse(error.service, error.context);\n  }\n  \n  if (error instanceof DatabaseError) {\n    return createDatabaseErrorResponse(error.operation, error.context);\n  }\n  \n  // Handle Prisma errors\n  if (error.code === 'P2002') {\n    return createConflictErrorResponse('Duplicate entry', { prismaError: error });\n  }\n  \n  if (error.code === 'P2025') {\n    return createNotFoundErrorResponse('Record not found', { prismaError: error });\n  }\n  \n  if (error.code === 'P2003') {\n    return createValidationErrorResponse(\n      { relation: 'Invalid reference' },\n      { prismaError: error }\n    );\n  }\n  \n  // Handle Zod validation errors\n  if (error.name === 'ZodError') {\n    const fieldErrors = error.errors.reduce((acc: any, err: any) => {\n      acc[err.path[0]] = err.message;\n      return acc;\n    }, {});\n    \n    return createValidationErrorResponse(fieldErrors, { zodError: error });\n  }\n  \n  // Handle network errors\n  if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {\n    return createExternalServiceErrorResponse('Network', { networkError: error });\n  }\n  \n  // Generic error response\n  return createInternalErrorResponse(error, request);\n}\n\n// Response creators\nfunction createValidationErrorResponse(fieldErrors: Record<string, string>, context?: any): NextResponse {\n  return NextResponse.json({\n    success: false,\n    error: 'Validation failed',\n    fieldErrors,\n    timestamp: new Date().toISOString(),\n    ...(context && { context })\n  }, { status: 400 });\n}\n\nfunction createAuthenticationErrorResponse(context?: any): NextResponse {\n  return NextResponse.json({\n    success: false,\n    error: 'Authentication required',\n    timestamp: new Date().toISOString(),\n    ...(context && { context })\n  }, { status: 401 });\n}\n\nfunction createAuthorizationErrorResponse(context?: any): NextResponse {\n  return NextResponse.json({\n    success: false,\n    error: 'Access denied',\n    timestamp: new Date().toISOString(),\n    ...(context && { context })\n  }, { status: 403 });\n}\n\nfunction createNotFoundErrorResponse(message: string, context?: any): NextResponse {\n  return NextResponse.json({\n    success: false,\n    error: message,\n    timestamp: new Date().toISOString(),\n    ...(context && { context })\n  }, { status: 404 });\n}\n\nfunction createConflictErrorResponse(message: string, context?: any): NextResponse {\n  return NextResponse.json({\n    success: false,\n    error: message,\n    timestamp: new Date().toISOString(),\n    ...(context && { context })\n  }, { status: 409 });\n}\n\nfunction createRateLimitErrorResponse(context?: any): NextResponse {\n  return NextResponse.json({\n    success: false,\n    error: 'Rate limit exceeded',\n    retryAfter: 60, // seconds\n    timestamp: new Date().toISOString(),\n    ...(context && { context })\n  }, { status: 429 });\n}\n\nfunction createExternalServiceErrorResponse(service: string, context?: any): NextResponse {\n  return NextResponse.json({\n    success: false,\n    error: `External service error: ${service}`,\n    timestamp: new Date().toISOString(),\n    ...(context && { context })\n  }, { status: 502 });\n}\n\nfunction createDatabaseErrorResponse(operation: string, context?: any): NextResponse {\n  return NextResponse.json({\n    success: false,\n    error: 'Database operation failed',\n    timestamp: new Date().toISOString(),\n    ...(context && { context })\n  }, { status: 500 });\n}\n\nfunction createInternalErrorResponse(error: any, request?: NextRequest): NextResponse {\n  const isDevelopment = process.env.NODE_ENV === 'development';\n  \n  return NextResponse.json({\n    success: false,\n    error: isDevelopment ? error.message : 'Internal server error',\n    ...(isDevelopment && { stack: error.stack }),\n    timestamp: new Date().toISOString(),\n    ...(request && { requestId: generateRequestId() })\n  }, { status: 500 });\n}\n\nfunction generateRequestId(): string {\n  return Math.random().toString(36).substring(2, 15);\n}\n```\n\n**4. USER-FACING ERROR HANDLING**\n```typescript\n// Client-side error handling\n// src/lib/errors/client-error-handler.ts\n\nexport interface UserFriendlyError {\n  title: string;\n  message: string;\n  type: 'error' | 'warning' | 'info';\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  retryable: boolean;\n}\n\nexport class ClientErrorHandler {\n  private static instance: ClientErrorHandler;\n  \n  static getInstance(): ClientErrorHandler {\n    if (!ClientErrorHandler.instance) {\n      ClientErrorHandler.instance = new ClientErrorHandler();\n    }\n    return ClientErrorHandler.instance;\n  }\n  \n  handleAPIError(error: any): UserFriendlyError {\n    // Handle different types of API errors\n    if (error.status === 400) {\n      return this.handleValidationError(error);\n    }\n    \n    if (error.status === 401) {\n      return {\n        title: 'Authentication Required',\n        message: 'Please log in to continue.',\n        type: 'error',\n        action: {\n          label: 'Go to Login',\n          onClick: () => window.location.href = '/admin/login'\n        },\n        retryable: false\n      };\n    }\n    \n    if (error.status === 403) {\n      return {\n        title: 'Access Denied',\n        message: 'You do not have permission to perform this action.',\n        type: 'error',\n        retryable: false\n      };\n    }\n    \n    if (error.status === 404) {\n      return {\n        title: 'Not Found',\n        message: 'The requested resource was not found.',\n        type: 'error',\n        retryable: false\n      };\n    }\n    \n    if (error.status === 409) {\n      return {\n        title: 'Conflict',\n        message: error.message || 'This action conflicts with existing data.',\n        type: 'warning',\n        retryable: true\n      };\n    }\n    \n    if (error.status === 429) {\n      return {\n        title: 'Too Many Requests',\n        message: 'Please wait a moment before trying again.',\n        type: 'warning',\n        retryable: true\n      };\n    }\n    \n    if (error.status >= 500) {\n      return {\n        title: 'Server Error',\n        message: 'Something went wrong on our end. Please try again.',\n        type: 'error',\n        action: {\n          label: 'Retry',\n          onClick: () => window.location.reload()\n        },\n        retryable: true\n      };\n    }\n    \n    // Default error\n    return {\n      title: 'Error',\n      message: error.message || 'An unexpected error occurred.',\n      type: 'error',\n      retryable: true\n    };\n  }\n  \n  private handleValidationError(error: any): UserFriendlyError {\n    if (error.fieldErrors) {\n      const fieldNames = Object.keys(error.fieldErrors);\n      const firstField = fieldNames[0];\n      \n      return {\n        title: 'Validation Error',\n        message: `Please check the ${firstField} field: ${error.fieldErrors[firstField]}`,\n        type: 'error',\n        retryable: false\n      };\n    }\n    \n    return {\n      title: 'Validation Error',\n      message: error.message || 'Please check your input and try again.',\n      type: 'error',\n      retryable: false\n    };\n  }\n  \n  handleNetworkError(error: any): UserFriendlyError {\n    return {\n      title: 'Connection Error',\n      message: 'Unable to connect to the server. Please check your internet connection.',\n      type: 'error',\n      action: {\n        label: 'Retry',\n        onClick: () => window.location.reload()\n      },\n      retryable: true\n    };\n  }\n  \n  handleTimeoutError(error: any): UserFriendlyError {\n    return {\n      title: 'Request Timeout',\n      message: 'The request took too long to complete. Please try again.',\n      type: 'warning',\n      action: {\n        label: 'Retry',\n        onClick: () => window.location.reload()\n      },\n      retryable: true\n    };\n  }\n}\n\nexport const clientErrorHandler = ClientErrorHandler.getInstance();\n```\n\n**5. ERROR RECOVERY PATTERNS**\n```typescript\n// Error recovery and retry mechanisms\n// src/lib/errors/error-recovery.ts\n\nexport interface RetryOptions {\n  maxAttempts: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitter: boolean;\n}\n\nexport class ErrorRecovery {\n  private static instance: ErrorRecovery;\n  \n  static getInstance(): ErrorRecovery {\n    if (!ErrorRecovery.instance) {\n      ErrorRecovery.instance = new ErrorRecovery();\n    }\n    return ErrorRecovery.instance;\n  }\n  \n  async withRetry<T>(\n    operation: () => Promise<T>,\n    options: Partial<RetryOptions> = {},\n    context?: string\n  ): Promise<T> {\n    const config: RetryOptions = {\n      maxAttempts: 3,\n      baseDelay: 1000,\n      maxDelay: 10000,\n      backoffMultiplier: 2,\n      jitter: true,\n      ...options\n    };\n    \n    let lastError: any;\n    \n    for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error;\n        \n        // Don't retry on certain error types\n        if (this.shouldNotRetry(error)) {\n          throw error;\n        }\n        \n        // If this is the last attempt, throw the error\n        if (attempt === config.maxAttempts) {\n          errorLogger.logError(error, {\n            context: `${context || 'operation'} failed after ${config.maxAttempts} attempts`,\n            attempts: config.maxAttempts\n          });\n          throw error;\n        }\n        \n        // Calculate delay with exponential backoff\n        const delay = this.calculateDelay(attempt, config);\n        \n        errorLogger.logWarning(\n          `${context || 'Operation'} failed, retrying in ${delay}ms (attempt ${attempt}/${config.maxAttempts})`,\n          { error: error.message, attempt, delay }\n        );\n        \n        await this.sleep(delay);\n      }\n    }\n    \n    throw lastError;\n  }\n  \n  private shouldNotRetry(error: any): boolean {\n    // Don't retry on client errors (4xx)\n    if (error.status >= 400 && error.status < 500) {\n      return true;\n    }\n    \n    // Don't retry on validation errors\n    if (error instanceof ValidationError) {\n      return true;\n    }\n    \n    // Don't retry on authentication/authorization errors\n    if (error instanceof AuthenticationError || error instanceof AuthorizationError) {\n      return true;\n    }\n    \n    return false;\n  }\n  \n  private calculateDelay(attempt: number, config: RetryOptions): number {\n    let delay = config.baseDelay * Math.pow(config.backoffMultiplier, attempt - 1);\n    \n    // Cap the delay\n    delay = Math.min(delay, config.maxDelay);\n    \n    // Add jitter to prevent thundering herd\n    if (config.jitter) {\n      delay = delay * (0.5 + Math.random() * 0.5);\n    }\n    \n    return Math.floor(delay);\n  }\n  \n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  // Circuit breaker pattern for external services\nexport class CircuitBreaker {\n  private static instances: Map<string, CircuitBreaker> = new Map();\n  \n  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';\n  private failureCount: number = 0;\n  private lastFailureTime: number = 0;\n  private successCount: number = 0;\n  \n  constructor(\n    private name: string,\n    private options: {\n      failureThreshold: number;\n      recoveryTimeout: number;\n      monitoringPeriod: number;\n    } = {\n      failureThreshold: 5,\n      recoveryTimeout: 60000, // 1 minute\n      monitoringPeriod: 10000 // 10 seconds\n    }\n  ) {\n    if (!CircuitBreaker.instances.has(name)) {\n      CircuitBreaker.instances.set(name, this);\n    }\n    return CircuitBreaker.instances.get(name)!;\n  }\n  \n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.state === 'OPEN') {\n      if (Date.now() - this.lastFailureTime > this.options.recoveryTimeout) {\n        this.state = 'HALF_OPEN';\n        this.successCount = 0;\n      } else {\n        throw new Error(`Circuit breaker is OPEN for ${this.name}`);\n      }\n    }\n    \n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n  \n  private onSuccess(): void {\n    this.failureCount = 0;\n    \n    if (this.state === 'HALF_OPEN') {\n      this.successCount++;\n      if (this.successCount >= 3) {\n        this.state = 'CLOSED';\n        errorLogger.logInfo(`Circuit breaker ${this.name} is now CLOSED`);\n      }\n    }\n  }\n  \n  private onFailure(): void {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n    \n    if (this.failureCount >= this.options.failureThreshold) {\n      this.state = 'OPEN';\n      errorLogger.logError(\n        new Error(`Circuit breaker ${this.name} is now OPEN`),\n        { failureCount: this.failureCount }\n      );\n    }\n  }\n  \n  getState(): string {\n    return this.state;\n  }\n  \n  static getInstance(name: string): CircuitBreaker {\n    if (!CircuitBreaker.instances.has(name)) {\n      new CircuitBreaker(name);\n    }\n    return CircuitBreaker.instances.get(name)!;\n  }\n}\n\nexport const errorRecovery = ErrorRecovery.getInstance();\n```\n\n**6. ERROR MONITORING AND ALERTING**\n```typescript\n// Error monitoring and alerting system\n// src/lib/errors/error-monitoring.ts\n\nexport interface ErrorMetrics {\n  totalErrors: number;\n  errorsByType: Record<string, number>;\n  errorsBySeverity: Record<string, number>;\n  errorRate: number;\n  lastErrorTime: Date;\n  topErrors: Array<{\n    message: string;\n    count: number;\n    lastOccurrence: Date;\n  }>;\n}\n\nexport class ErrorMonitor {\n  private static instance: ErrorMonitor;\n  private metrics: ErrorMetrics;\n  private alertThresholds: {\n    errorRate: number;\n    criticalErrors: number;\n  };\n  \n  static getInstance(): ErrorMonitor {\n    if (!ErrorMonitor.instance) {\n      ErrorMonitor.instance = new ErrorMonitor();\n    }\n    return ErrorMonitor.instance;\n  }\n  \n  constructor() {\n    this.metrics = {\n      totalErrors: 0,\n      errorsByType: {},\n      errorsBySeverity: {},\n      errorRate: 0,\n      lastErrorTime: new Date(),\n      topErrors: []\n    };\n    \n    this.alertThresholds = {\n      errorRate: 0.05, // 5% error rate\n      criticalErrors: 10 // 10 critical errors per hour\n    };\n    \n    // Start monitoring\n    this.startMonitoring();\n  }\n  \n  recordError(error: ApplicationError): void {\n    this.metrics.totalErrors++;\n    this.metrics.lastErrorTime = new Date();\n    \n    // Update type metrics\n    this.metrics.errorsByType[error.type] = \n      (this.metrics.errorsByType[error.type] || 0) + 1;\n    \n    // Update severity metrics\n    this.metrics.errorsBySeverity[error.severity] = \n      (this.metrics.errorsBySeverity[error.severity] || 0) + 1;\n    \n    // Update top errors\n    this.updateTopErrors(error);\n    \n    // Check for alerts\n    this.checkAlerts(error);\n  }\n  \n  private updateTopErrors(error: ApplicationError): void {\n    const existingError = this.metrics.topErrors.find(\n      e => e.message === error.message\n    );\n    \n    if (existingError) {\n      existingError.count++;\n      existingError.lastOccurrence = new Date();\n    } else {\n      this.metrics.topErrors.push({\n        message: error.message,\n        count: 1,\n        lastOccurrence: new Date()\n      });\n    }\n    \n    // Sort by count and keep top 10\n    this.metrics.topErrors.sort((a, b) => b.count - a.count);\n    this.metrics.topErrors = this.metrics.topErrors.slice(0, 10);\n  }\n  \n  private checkAlerts(error: ApplicationError): void {\n    // Check for critical error threshold\n    if (error.severity === 'CRITICAL') {\n      const criticalCount = this.metrics.errorsBySeverity['CRITICAL'] || 0;\n      if (criticalCount >= this.alertThresholds.criticalErrors) {\n        this.sendAlert('critical', `Too many critical errors: ${criticalCount}`);\n      }\n    }\n    \n    // Check for high error rate\n    this.calculateErrorRate();\n    if (this.metrics.errorRate > this.alertThresholds.errorRate) {\n      this.sendAlert('error-rate', `High error rate: ${this.metrics.errorRate.toFixed(2)}%`);\n    }\n  }\n  \n  private calculateErrorRate(): void {\n    // Calculate error rate over the last hour\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    const recentErrors = this.metrics.totalErrors; // Simplified for example\n    \n    // This would need to be more sophisticated in a real implementation\n    this.metrics.errorRate = recentErrors / 1000; // Simplified calculation\n  }\n  \n  private sendAlert(type: string, message: string): void {\n    // Send alert to monitoring service\n    console.error(`ALERT [${type}]: ${message}`);\n    \n    // This could integrate with:\n    // - Slack notifications\n    // - Email alerts\n    // - PagerDuty\n    // - Custom webhook\n  }\n  \n  private startMonitoring(): void {\n    // Monitor error metrics every 5 minutes\n    setInterval(() => {\n      this.generateReport();\n    }, 5 * 60 * 1000);\n  }\n  \n  private generateReport(): void {\n    const report = {\n      timestamp: new Date().toISOString(),\n      metrics: this.metrics,\n      health: this.getHealthStatus()\n    };\n    \n    // Send to monitoring service\n    console.log('Error monitoring report:', report);\n  }\n  \n  getHealthStatus(): 'healthy' | 'degraded' | 'unhealthy' {\n    if (this.metrics.errorRate > 0.1) return 'unhealthy';\n    if (this.metrics.errorRate > 0.05) return 'degraded';\n    return 'healthy';\n  }\n  \n  getMetrics(): ErrorMetrics {\n    return { ...this.metrics };\n  }\n}\n\nexport const errorMonitor = ErrorMonitor.getInstance();\n```\n\n**7. ERROR HANDLING IN PRACTICE**\n```typescript\n// Practical error handling examples\n// src/lib/errors/practical-examples.ts\n\n// API route error handling\nexport async function handleAPIRequest<T>(\n  operation: () => Promise<T>,\n  context: string\n): Promise<NextResponse> {\n  try {\n    const result = await operation();\n    return NextResponse.json({ success: true, data: result });\n  } catch (error) {\n    return handleError(error);\n  }\n}\n\n// Database operation error handling\nexport async function handleDatabaseOperation<T>(\n  operation: () => Promise<T>,\n  context: string\n): Promise<T> {\n  try {\n    return await operation();\n  } catch (error) {\n    // Log the error with context\n    errorLogger.logError(error, { context, operation: 'database' });\n    \n    // Record metrics\n    errorMonitor.recordError(\n      new DatabaseError(context, error.message, { operation: context })\n    );\n    \n    throw error;\n  }\n}\n\n// External service error handling\nexport async function handleExternalService<T>(\n  serviceName: string,\n  operation: () => Promise<T>,\n  context: string\n): Promise<T> {\n  const circuitBreaker = CircuitBreaker.getInstance(serviceName);\n  \n  try {\n    return await circuitBreaker.execute(async () => {\n      return await errorRecovery.withRetry(operation, {\n        maxAttempts: 3,\n        baseDelay: 1000\n      }, `${serviceName} ${context}`);\n    });\n  } catch (error) {\n    errorLogger.logError(error, { service: serviceName, context });\n    \n    errorMonitor.recordError(\n      new ExternalServiceError(serviceName, error.message, { context })\n    );\n    \n    throw error;\n  }\n}\n\n// Form validation error handling\nexport function handleFormValidation(\n  data: any,\n  schema: any\n): { isValid: boolean; errors?: Record<string, string> } {\n  try {\n    schema.parse(data);\n    return { isValid: true };\n  } catch (error) {\n    if (error.name === 'ZodError') {\n      const fieldErrors = error.errors.reduce((acc: any, err: any) => {\n        acc[err.path[0]] = err.message;\n        return acc;\n      }, {});\n      \n      return { isValid: false, errors: fieldErrors };\n    }\n    \n    throw error;\n  }\n}\n```\n\nThis comprehensive error handling system provides robust error management, logging, monitoring, and recovery mechanisms for the RSVP application, ensuring reliable operation and quick issue resolution."}


