{"instruction": "How does webhook handling work?", "input": "Explain webhook processing for SendGrid and external events", "output": "I'll explain the complete webhook handling system. Here's how webhooks are processed for SendGrid and external events:\n\n**WEBHOOK HANDLING SYSTEM**\n\n**1. SENDGRID WEBHOOK PROCESSING**\n```typescript\n// SendGrid webhook endpoint\n// src/app/api/webhooks/sendgrid/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { handleSendGridWebhook } from '@/lib/sendgrid-email';\n\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    \n    // Validate webhook signature (if configured)\n    const signature = req.headers.get('x-twilio-email-event-webhook-signature');\n    const timestamp = req.headers.get('x-twilio-email-event-webhook-timestamp');\n    \n    if (signature && timestamp) {\n      const isValid = verifySendGridSignature(body, signature, timestamp);\n      if (!isValid) {\n        return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });\n      }\n    }\n    \n    // Process webhook events\n    const result = await handleSendGridWebhook(body);\n    \n    return NextResponse.json({ success: true, processed: result.processed });\n  } catch (error) {\n    console.error('SendGrid webhook error:', error);\n    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 });\n  }\n}\n\n// SendGrid webhook signature verification\nfunction verifySendGridSignature(\n  payload: any,\n  signature: string,\n  timestamp: string\n): boolean {\n  const webhookSecret = process.env.SENDGRID_WEBHOOK_SECRET;\n  if (!webhookSecret) {\n    // If no secret configured, allow all webhooks (not recommended for production)\n    return true;\n  }\n  \n  const crypto = require('crypto');\n  const expectedSignature = crypto\n    .createHmac('sha256', webhookSecret)\n    .update(timestamp + JSON.stringify(payload))\n    .digest('base64');\n  \n  return signature === expectedSignature;\n}\n```\n\n**2. SENDGRID WEBHOOK HANDLER**\n```typescript\n// SendGrid webhook event processing\n// src/lib/sendgrid-email.ts\nexport async function handleSendGridWebhook(events: any[]): Promise<{\n  processed: number;\n  errors: number;\n}> {\n  const results = {\n    processed: 0,\n    errors: 0\n  };\n\n  for (const event of events) {\n    try {\n      await processSendGridEvent(event);\n      results.processed++;\n    } catch (error) {\n      console.error('Error processing SendGrid event:', error);\n      results.errors++;\n    }\n  }\n\n  return results;\n}\n\nasync function processSendGridEvent(event: any) {\n  const {\n    event: eventType,\n    email,\n    timestamp,\n    sg_message_id,\n    reason,\n    url,\n    useragent,\n    ip,\n    category,\n    unique_args,\n    ...otherData\n  } = event;\n\n  // Find corresponding email job or RSVP\n  let emailJob = null;\n  let rsvp = null;\n\n  // Try to find by SendGrid message ID\n  if (sg_message_id) {\n    emailJob = await prisma.emailJob.findFirst({\n      where: {\n        providerMessageId: sg_message_id\n      }\n    });\n  }\n\n  // Try to find by email address\n  if (!emailJob) {\n    rsvp = await prisma.rsvp.findUnique({\n      where: { email }\n    });\n  }\n\n  // Process based on event type\n  switch (eventType) {\n    case 'delivered':\n      await handleEmailDelivered(emailJob, rsvp, event);\n      break;\n    case 'bounce':\n      await handleEmailBounce(emailJob, rsvp, event);\n      break;\n    case 'dropped':\n      await handleEmailDropped(emailJob, rsvp, event);\n      break;\n    case 'open':\n      await handleEmailOpen(emailJob, rsvp, event);\n      break;\n    case 'click':\n      await handleEmailClick(emailJob, rsvp, event);\n      break;\n    case 'spam_report':\n      await handleSpamReport(emailJob, rsvp, event);\n      break;\n    case 'unsubscribe':\n      await handleUnsubscribe(emailJob, rsvp, event);\n      break;\n    case 'group_unsubscribe':\n      await handleGroupUnsubscribe(emailJob, rsvp, event);\n      break;\n    case 'processed':\n      await handleEmailProcessed(emailJob, rsvp, event);\n      break;\n    default:\n      console.log('Unknown SendGrid event type:', eventType);\n  }\n}\n```\n\n**3. EMAIL EVENT HANDLERS**\n```typescript\n// Individual email event handlers\nasync function handleEmailDelivered(emailJob: any, rsvp: any, event: any) {\n  if (emailJob) {\n    // Update email job status\n    await prisma.emailJob.update({\n      where: { id: emailJob.id },\n      data: {\n        status: 'delivered',\n        meta: {\n          ...emailJob.meta,\n          deliveredAt: new Date(event.timestamp * 1000).toISOString(),\n          deliveryData: event\n        }\n      }\n    });\n\n    // Create email event record\n    await prisma.emailEvent.create({\n      data: {\n        jobId: emailJob.id,\n        type: 'delivered',\n        meta: event\n      }\n    });\n  }\n\n  // Post to LeadMine if applicable\n  if (emailJob?.meta?.inviteToken) {\n    await postLeadMineEvent({\n      token: emailJob.meta.inviteToken,\n      businessId: emailJob.meta.businessId,\n      type: 'email_delivered',\n      meta: {\n        messageId: event.sg_message_id,\n        deliveredAt: new Date(event.timestamp * 1000).toISOString()\n      }\n    });\n  }\n}\n\nasync function handleEmailBounce(emailJob: any, rsvp: any, event: any) {\n  if (emailJob) {\n    // Update email job status\n    await prisma.emailJob.update({\n      where: { id: emailJob.id },\n      data: {\n        status: 'bounced',\n        error: event.reason,\n        meta: {\n          ...emailJob.meta,\n          bouncedAt: new Date(event.timestamp * 1000).toISOString(),\n          bounceData: event\n        }\n      }\n    });\n\n    // Create email event record\n    await prisma.emailEvent.create({\n      data: {\n        jobId: emailJob.id,\n        type: 'bounced',\n        meta: event\n      }\n    });\n  }\n\n  // Mark audience member as unsubscribed for hard bounces\n  if (event.type === 'bounce' && event.reason?.includes('hard')) {\n    await prisma.audienceMember.updateMany({\n      where: {\n        primaryEmail: event.email\n      },\n      data: {\n        unsubscribed: true,\n        meta: {\n          unsubscribedAt: new Date().toISOString(),\n          unsubscribedReason: 'hard_bounce',\n          bounceReason: event.reason\n        }\n      }\n    });\n  }\n}\n\nasync function handleEmailOpen(emailJob: any, rsvp: any, event: any) {\n  if (emailJob) {\n    // Update email job with open tracking\n    await prisma.emailJob.update({\n      where: { id: emailJob.id },\n      data: {\n        meta: {\n          ...emailJob.meta,\n          openedAt: new Date(event.timestamp * 1000).toISOString(),\n          openData: event\n        }\n      }\n    });\n\n    // Create email event record\n    await prisma.emailEvent.create({\n      data: {\n        jobId: emailJob.id,\n        type: 'opened',\n        meta: event\n      }\n    });\n  }\n\n  // Post to LeadMine\n  if (emailJob?.meta?.inviteToken) {\n    await postLeadMineEvent({\n      token: emailJob.meta.inviteToken,\n      businessId: emailJob.meta.businessId,\n      type: 'email_opened',\n      meta: {\n        messageId: event.sg_message_id,\n        openedAt: new Date(event.timestamp * 1000).toISOString(),\n        userAgent: event.useragent,\n        ip: event.ip\n      }\n    });\n  }\n}\n\nasync function handleEmailClick(emailJob: any, rsvp: any, event: any) {\n  if (emailJob) {\n    // Update email job with click tracking\n    await prisma.emailJob.update({\n      where: { id: emailJob.id },\n      data: {\n        meta: {\n          ...emailJob.meta,\n          clickedAt: new Date(event.timestamp * 1000).toISOString(),\n          clickData: event\n        }\n      }\n    });\n\n    // Create email event record\n    await prisma.emailEvent.create({\n      data: {\n        jobId: emailJob.id,\n        type: 'clicked',\n        meta: event\n      }\n    });\n  }\n\n  // Post to LeadMine\n  if (emailJob?.meta?.inviteToken) {\n    await postLeadMineEvent({\n      token: emailJob.meta.inviteToken,\n      businessId: emailJob.meta.businessId,\n      type: 'email_clicked',\n      meta: {\n        messageId: event.sg_message_id,\n        clickedAt: new Date(event.timestamp * 1000).toISOString(),\n        url: event.url,\n        userAgent: event.useragent,\n        ip: event.ip\n      }\n    });\n  }\n}\n\nasync function handleUnsubscribe(emailJob: any, rsvp: any, event: any) {\n  // Mark audience member as unsubscribed\n  await prisma.audienceMember.updateMany({\n    where: {\n      primaryEmail: event.email\n    },\n    data: {\n      unsubscribed: true,\n      meta: {\n        unsubscribedAt: new Date().toISOString(),\n        unsubscribedReason: 'user_request',\n        unsubscribeData: event\n      }\n    }\n  });\n\n  // Create email event record if email job exists\n  if (emailJob) {\n    await prisma.emailEvent.create({\n      data: {\n        jobId: emailJob.id,\n        type: 'unsubscribed',\n        meta: event\n      }\n    });\n  }\n\n  // Post to LeadMine\n  if (emailJob?.meta?.inviteToken) {\n    await postLeadMineEvent({\n      token: emailJob.meta.inviteToken,\n      businessId: emailJob.meta.businessId,\n      type: 'unsubscribed',\n      meta: {\n        messageId: event.sg_message_id,\n        unsubscribedAt: new Date(event.timestamp * 1000).toISOString()\n      }\n    });\n  }\n}\n```\n\n**4. IMPROVMX WEBHOOK HANDLING**\n```typescript\n// ImprovMX webhook for email receiving\n// src/app/api/webhooks/improvmx/route.ts\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    \n    // Process incoming email\n    const { from, to, subject, body: emailBody, headers } = body;\n    \n    // Determine email type and route accordingly\n    if (to.includes('bounces@')) {\n      await handleBounceEmail({ from, subject, emailBody, headers });\n    } else if (to.includes('unsubscribe@')) {\n      await handleUnsubscribeEmail({ from, subject, emailBody, headers });\n    } else if (to.includes('support@')) {\n      await handleSupportEmail({ from, subject, emailBody, headers });\n    } else {\n      await handleReplyEmail({ from, subject, emailBody, headers });\n    }\n    \n    return NextResponse.json({ received: true });\n  } catch (error) {\n    console.error('ImprovMX webhook error:', error);\n    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 });\n  }\n}\n\n// Bounce email handling\nasync function handleBounceEmail({ from, subject, emailBody, headers }) {\n  try {\n    // Extract original recipient from bounce email\n    const recipientMatch = emailBody.match(/Original-Recipient: (.+)/i);\n    const recipient = recipientMatch ? recipientMatch[1] : null;\n    \n    if (recipient) {\n      // Update database to mark email as bounced\n      await prisma.audienceMember.updateMany({\n        where: { primaryEmail: recipient },\n        data: { \n          unsubscribed: true,\n          meta: {\n            bounceReason: 'Hard bounce',\n            bouncedAt: new Date().toISOString(),\n            bounceSubject: subject,\n            bounceFrom: from\n          }\n        }\n      });\n      \n      // Log bounce event\n      await prisma.emailEvent.create({\n        data: {\n          type: 'bounce',\n          meta: {\n            recipient,\n            bounceType: 'hard',\n            bounceReason: subject,\n            processedAt: new Date().toISOString()\n          }\n        }\n      });\n    }\n  } catch (error) {\n    console.error('Bounce processing failed:', error);\n  }\n}\n\n// Unsubscribe email handling\nasync function handleUnsubscribeEmail({ from, subject, emailBody, headers }) {\n  try {\n    // Extract email address from unsubscribe request\n    const emailMatch = from.match(/<(.+)>/);\n    const email = emailMatch ? emailMatch[1] : from;\n    \n    // Update database to mark as unsubscribed\n    await prisma.audienceMember.updateMany({\n      where: { primaryEmail: email },\n      data: { \n        unsubscribed: true,\n        meta: {\n          unsubscribedAt: new Date().toISOString(),\n          unsubscribeMethod: 'email',\n          unsubscribeSubject: subject\n        }\n      }\n    });\n    \n    // Log unsubscribe event\n    await prisma.emailEvent.create({\n      data: {\n        type: 'unsubscribe',\n        meta: {\n          email,\n          unsubscribeMethod: 'email',\n          processedAt: new Date().toISOString()\n        }\n      }\n    });\n    \n    // Send confirmation email\n    await sendUnsubscribeConfirmation(email);\n  } catch (error) {\n    console.error('Unsubscribe processing failed:', error);\n  }\n}\n```\n\n**5. WEBHOOK SECURITY**\n```typescript\n// Webhook security and validation\nfunction validateWebhookRequest(req: NextRequest, webhookSecret?: string): boolean {\n  // Check IP whitelist (if configured)\n  const allowedIPs = process.env.WEBHOOK_ALLOWED_IPS?.split(',') || [];\n  if (allowedIPs.length > 0) {\n    const clientIP = req.headers.get('x-forwarded-for')?.split(',')[0]?.trim();\n    if (!allowedIPs.includes(clientIP)) {\n      return false;\n    }\n  }\n  \n  // Check webhook secret\n  if (webhookSecret) {\n    const signature = req.headers.get('x-webhook-signature');\n    if (!signature) {\n      return false;\n    }\n    \n    const expectedSignature = crypto\n      .createHmac('sha256', webhookSecret)\n      .update(JSON.stringify(req.body))\n      .digest('hex');\n    \n    return signature === expectedSignature;\n  }\n  \n  return true;\n}\n\n// Rate limiting for webhooks\nexport async function checkWebhookRateLimit(\n  webhookType: string,\n  clientIP: string\n): Promise<boolean> {\n  const rateLimitKey = `webhook:${webhookType}:${clientIP}`;\n  const rateLimit = await getRateLimit(rateLimitKey);\n  \n  if (rateLimit.count >= 100) { // 100 requests per hour\n    return false;\n  }\n  \n  await incrementRateLimit(rateLimitKey, 3600); // 1 hour\n  return true;\n}\n```\n\n**6. WEBHOOK MONITORING**\n```typescript\n// Webhook monitoring and logging\nexport class WebhookMonitor {\n  private static instance: WebhookMonitor;\n  private webhookStats: Map<string, any> = new Map();\n  \n  static getInstance(): WebhookMonitor {\n    if (!WebhookMonitor.instance) {\n      WebhookMonitor.instance = new WebhookMonitor();\n    }\n    return WebhookMonitor.instance;\n  }\n  \n  recordWebhookEvent(webhookType: string, eventType: string, success: boolean) {\n    const key = `${webhookType}:${eventType}`;\n    const stats = this.webhookStats.get(key) || {\n      total: 0,\n      success: 0,\n      errors: 0,\n      lastProcessed: null\n    };\n    \n    stats.total++;\n    if (success) {\n      stats.success++;\n    } else {\n      stats.errors++;\n    }\n    stats.lastProcessed = new Date().toISOString();\n    \n    this.webhookStats.set(key, stats);\n  }\n  \n  getWebhookStats(): Record<string, any> {\n    return Object.fromEntries(this.webhookStats);\n  }\n  \n  getWebhookHealth(): {\n    healthy: boolean;\n    issues: string[];\n  } {\n    const issues: string[] = [];\n    \n    for (const [key, stats] of this.webhookStats) {\n      const errorRate = stats.errors / stats.total;\n      if (errorRate > 0.1) { // More than 10% error rate\n        issues.push(`${key} has high error rate: ${(errorRate * 100).toFixed(1)}%`);\n      }\n      \n      const lastProcessed = new Date(stats.lastProcessed);\n      const timeSinceLastProcessed = Date.now() - lastProcessed.getTime();\n      if (timeSinceLastProcessed > 24 * 60 * 60 * 1000) { // 24 hours\n        issues.push(`${key} hasn't processed events in 24+ hours`);\n      }\n    }\n    \n    return {\n      healthy: issues.length === 0,\n      issues\n    };\n  }\n}\n```\n\n**7. WEBHOOK CONFIGURATION**\n```typescript\n// Webhook configuration and setup\nexport const webhookConfig = {\n  sendgrid: {\n    enabled: Boolean(process.env.SENDGRID_WEBHOOK_SECRET),\n    endpoint: '/api/webhooks/sendgrid',\n    events: [\n      'delivered', 'bounce', 'dropped', 'open', 'click',\n      'spam_report', 'unsubscribe', 'group_unsubscribe', 'processed'\n    ],\n    secret: process.env.SENDGRID_WEBHOOK_SECRET\n  },\n  \n  improvmx: {\n    enabled: Boolean(process.env.IMPROVMX_WEBHOOK_SECRET),\n    endpoint: '/api/webhooks/improvmx',\n    events: ['email_received'],\n    secret: process.env.IMPROVMX_WEBHOOK_SECRET\n  },\n  \n  leadmine: {\n    enabled: Boolean(process.env.LEADMINE_WEBHOOK_SECRET),\n    endpoint: '/api/webhooks/leadmine',\n    events: ['business_updated', 'business_deleted', 'invite_token_generated'],\n    secret: process.env.LEADMINE_WEBHOOK_SECRET\n  }\n};\n\n// Webhook health check\nexport async function checkWebhookHealth(): Promise<{\n  sendgrid: boolean;\n  improvmx: boolean;\n  leadmine: boolean;\n}> {\n  return {\n    sendgrid: webhookConfig.sendgrid.enabled,\n    improvmx: webhookConfig.improvmx.enabled,\n    leadmine: webhookConfig.leadmine.enabled\n  };\n}\n```\n\nThis comprehensive webhook handling system provides secure processing of SendGrid email events, ImprovMX email receiving, and external service integrations with proper error handling, monitoring, and security measures."}


