{"instruction": "How do database operations work in this application?", "input": "Explain the complete database system including Prisma ORM, relationships, queries, and data flow", "output": "I'll explain the comprehensive database operations system. Here's how the database layer works with Prisma ORM and PostgreSQL:\n\n**DATABASE OPERATIONS ARCHITECTURE**\n\n**1. PRISMA ORM CONFIGURATION**\n```typescript\n// Prisma client singleton configuration\n// src/lib/prisma.ts\nimport { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n  datasources: {\n    db: {\n      url: process.env.DATABASE_URL,\n    },\n  },\n});\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n\n// Connection management\nprisma.$connect().catch((error) => {\n  console.error('Failed to connect to database:', error);\n  process.exit(1);\n});\n\n// Graceful shutdown\nprocess.on('beforeExit', async () => {\n  await prisma.$disconnect();\n});\n```\n\n**2. DATABASE SCHEMA RELATIONSHIPS**\n```prisma\n// Complete schema with relationships\n// prisma/schema.prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// Core entities and their relationships\nmodel AudienceGroup {\n  id          String             @id @default(cuid())\n  name        String\n  description String?\n  color       String?            @default(\"#10b981\")\n  criteria    Json?\n  meta        Json\n  createdAt   DateTime           @default(now())\n  updatedAt   DateTime           @updatedAt\n  \n  // Relationships\n  members     AudienceMember[]\n  schedules   CampaignSchedule[]\n  \n  @@map(\"audience_groups\")\n}\n\nmodel AudienceMember {\n  id             String        @id @default(cuid())\n  groupId        String\n  businessId     String\n  businessName   String?\n  primaryEmail   String\n  secondaryEmail String?\n  tagsSnapshot   String[]\n  inviteToken    String?\n  meta           Json\n  createdAt      DateTime      @default(now())\n  unsubscribed   Boolean       @default(false)\n  \n  // Relationships\n  group          AudienceGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)\n  \n  @@unique([groupId, businessId])\n  @@index([groupId])\n  @@index([businessId])\n  @@map(\"audience_members\")\n}\n\nmodel Campaign {\n  id          String   @id @default(cuid())\n  name        String\n  description String?\n  status      CampaignStatus @default(DRAFT)\n  meta        Json\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  \n  // Relationships\n  templates   CampaignTemplate[]\n  schedules   CampaignSchedule[]\n  \n  @@map(\"campaigns\")\n}\n\nmodel CampaignTemplate {\n  id          String   @id @default(cuid())\n  campaignId  String\n  name        String\n  subject     String\n  content     String\n  htmlContent String?\n  variables   Json\n  meta        Json\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  \n  // Relationships\n  campaign    Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)\n  \n  @@map(\"campaign_templates\")\n}\n\nmodel CampaignSchedule {\n  id          String   @id @default(cuid())\n  campaignId  String\n  groupId     String\n  name        String\n  description String?\n  status      ScheduleStatus @default(PENDING)\n  scheduledAt DateTime\n  meta        Json\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  \n  // Relationships\n  campaign    Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)\n  group       AudienceGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)\n  sends       CampaignSend[]\n  \n  @@map(\"campaign_schedules\")\n}\n\nmodel CampaignSend {\n  id         String   @id @default(cuid())\n  scheduleId String\n  status     SendStatus @default(PENDING)\n  sentAt     DateTime?\n  meta       Json\n  createdAt  DateTime @default(now())\n  \n  // Relationships\n  schedule   CampaignSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)\n  jobs       EmailJob[]\n  \n  @@map(\"campaign_sends\")\n}\n\nmodel EmailJob {\n  id        String   @id @default(cuid())\n  sendId    String\n  memberId  String\n  status    JobStatus @default(PENDING)\n  sentAt    DateTime?\n  meta      Json\n  createdAt DateTime @default(now())\n  \n  // Relationships\n  send      CampaignSend @relation(fields: [sendId], references: [id], onDelete: Cascade)\n  member    AudienceMember @relation(fields: [memberId], references: [id], onDelete: Cascade)\n  events    EmailEvent[]\n  \n  @@map(\"email_jobs\")\n}\n\nmodel EmailEvent {\n  id        String   @id @default(cuid())\n  jobId     String\n  type      EmailEventType\n  data      Json\n  createdAt DateTime @default(now())\n  \n  // Relationships\n  job       EmailJob @relation(fields: [jobId], references: [id], onDelete: Cascade)\n  \n  @@map(\"email_events\")\n}\n\nmodel RSVP {\n  id                String   @id @default(cuid())\n  fullName          String\n  organization      String?\n  email             String\n  phone             String?\n  attendanceStatus  AttendanceStatus\n  attendeeCount     Int\n  dietaryPreference DietaryPreference\n  dietaryOther      String?\n  accessibilityNeeds String?\n  referralSource    ReferralSource\n  referralOther     String?\n  wantsResources    Boolean  @default(false)\n  wantsAudit        Boolean  @default(false)\n  learningGoal      String?\n  ipHash            String?\n  userAgent         String?\n  utmSource         String?\n  utmMedium         String?\n  utmCampaign       String?\n  utmContent        String?\n  utmTerm           String?\n  referrer          String?\n  meta              Json\n  createdAt         DateTime @default(now())\n  updatedAt         DateTime @updatedAt\n  \n  @@map(\"rsvps\")\n}\n\nmodel Visit {\n  id                String   @id @default(cuid())\n  visitorId         String\n  sessionId         String\n  page              String\n  referrer          String?\n  utmSource         String?\n  utmMedium         String?\n  utmCampaign       String?\n  utmContent        String?\n  utmTerm           String?\n  device            String?\n  browser           String?\n  os                String?\n  country           String?\n  region            String?\n  city              String?\n  language          String?\n  screenResolution  String?\n  viewportSize      String?\n  connectionType    String?\n  loadTime          Int?\n  bounceRate        Float?\n  timeOnPage        Int?\n  scrollDepth       Float?\n  clickCount        Int?\n  meta              Json\n  createdAt         DateTime @default(now())\n  \n  @@index([visitorId])\n  @@index([sessionId])\n  @@index([createdAt])\n  @@map(\"visits\")\n}\n\n// Enums\nenum CampaignStatus {\n  DRAFT\n  SCHEDULED\n  RUNNING\n  PAUSED\n  COMPLETED\n  CANCELLED\n}\n\nenum ScheduleStatus {\n  PENDING\n  RUNNING\n  COMPLETED\n  CANCELLED\n}\n\nenum SendStatus {\n  PENDING\n  RUNNING\n  COMPLETED\n  FAILED\n}\n\nenum JobStatus {\n  PENDING\n  SENDING\n  SENT\n  FAILED\n  BOUNCED\n  DELIVERED\n  OPENED\n  CLICKED\n}\n\nenum EmailEventType {\n  SENT\n  DELIVERED\n  OPENED\n  CLICKED\n  BOUNCED\n  UNSUBSCRIBED\n  SPAM\n}\n\nenum AttendanceStatus {\n  YES\n  NO\n  MAYBE\n}\n\nenum DietaryPreference {\n  NONE\n  VEGETARIAN\n  VEGAN\n  GLUTEN_FREE\n  OTHER\n}\n\nenum ReferralSource {\n  WORD_OF_MOUTH\n  SOCIAL_MEDIA\n  WEBSITE\n  EMAIL\n  OTHER\n}\n```\n\n**3. DATABASE QUERY PATTERNS**\n```typescript\n// Comprehensive query patterns\n// src/lib/database/queries.ts\n\n// Campaign queries with relationships\nexport async function getCampaignWithDetails(campaignId: string) {\n  return await prisma.campaign.findUnique({\n    where: { id: campaignId },\n    include: {\n      templates: {\n        orderBy: { createdAt: 'desc' }\n      },\n      schedules: {\n        include: {\n          group: {\n            include: {\n              members: {\n                where: { unsubscribed: false }\n              },\n              _count: {\n                select: { members: true }\n              }\n            }\n          },\n          sends: {\n            include: {\n              jobs: {\n                include: {\n                  member: true,\n                  events: {\n                    orderBy: { createdAt: 'desc' },\n                    take: 10\n                  }\n                }\n              },\n              _count: {\n                select: { jobs: true }\n              }\n            },\n            orderBy: { createdAt: 'desc' }\n          }\n        },\n        orderBy: { scheduledAt: 'asc' }\n      }\n    }\n  });\n}\n\n// Audience analytics with aggregation\nexport async function getAudienceAnalytics(groupId: string, dateRange?: { from: Date; to: Date }) {\n  const whereClause: any = { groupId };\n  \n  if (dateRange) {\n    whereClause.createdAt = {\n      gte: dateRange.from,\n      lte: dateRange.to\n    };\n  }\n  \n  const [totalMembers, activeMembers, unsubscribedMembers, engagementStats] = await Promise.all([\n    // Total members count\n    prisma.audienceMember.count({\n      where: whereClause\n    }),\n    \n    // Active members (not unsubscribed)\n    prisma.audienceMember.count({\n      where: {\n        ...whereClause,\n        unsubscribed: false\n      }\n    }),\n    \n    // Unsubscribed members\n    prisma.audienceMember.count({\n      where: {\n        ...whereClause,\n        unsubscribed: true\n      }\n    }),\n    \n    // Engagement statistics\n    prisma.emailEvent.groupBy({\n      by: ['type'],\n      where: {\n        job: {\n          member: whereClause\n        },\n        createdAt: dateRange ? {\n          gte: dateRange.from,\n          lte: dateRange.to\n        } : undefined\n      },\n      _count: {\n        type: true\n      }\n    })\n  ]);\n  \n  return {\n    totalMembers,\n    activeMembers,\n    unsubscribedMembers,\n    unsubscribeRate: totalMembers > 0 ? (unsubscribedMembers / totalMembers) * 100 : 0,\n    engagementStats: engagementStats.reduce((acc, stat) => {\n      acc[stat.type] = stat._count.type;\n      return acc;\n    }, {} as Record<string, number>)\n  };\n}\n\n// Complex filtering with pagination\nexport async function searchAudienceMembers(\n  groupId: string,\n  filters: {\n    search?: string;\n    tags?: string[];\n    unsubscribed?: boolean;\n    dateRange?: { from: Date; to: Date };\n  },\n  pagination: {\n    page: number;\n    limit: number;\n  }\n) {\n  const whereClause: any = { groupId };\n  \n  // Text search across multiple fields\n  if (filters.search) {\n    whereClause.OR = [\n      { businessName: { contains: filters.search, mode: 'insensitive' } },\n      { primaryEmail: { contains: filters.search, mode: 'insensitive' } },\n      { secondaryEmail: { contains: filters.search, mode: 'insensitive' } }\n    ];\n  }\n  \n  // Tag filtering\n  if (filters.tags && filters.tags.length > 0) {\n    whereClause.tagsSnapshot = {\n      hasSome: filters.tags\n    };\n  }\n  \n  // Unsubscribed filter\n  if (filters.unsubscribed !== undefined) {\n    whereClause.unsubscribed = filters.unsubscribed;\n  }\n  \n  // Date range filter\n  if (filters.dateRange) {\n    whereClause.createdAt = {\n      gte: filters.dateRange.from,\n      lte: filters.dateRange.to\n    };\n  }\n  \n  const [members, totalCount] = await Promise.all([\n    prisma.audienceMember.findMany({\n      where: whereClause,\n      include: {\n        group: {\n          select: {\n            name: true,\n            color: true\n          }\n        }\n      },\n      orderBy: { createdAt: 'desc' },\n      skip: (pagination.page - 1) * pagination.limit,\n      take: pagination.limit\n    }),\n    prisma.audienceMember.count({ where: whereClause })\n  ]);\n  \n  return {\n    members,\n    pagination: {\n      page: pagination.page,\n      limit: pagination.limit,\n      total: totalCount,\n      pages: Math.ceil(totalCount / pagination.limit)\n    }\n  };\n}\n\n// Transaction operations\nexport async function createCampaignWithSchedule(\n  campaignData: {\n    name: string;\n    description?: string;\n    templates: Array<{\n      name: string;\n      subject: string;\n      content: string;\n      htmlContent?: string;\n      variables: any;\n    }>;\n    schedules: Array<{\n      groupId: string;\n      name: string;\n      description?: string;\n      scheduledAt: Date;\n    }>;\n  }\n) {\n  return await prisma.$transaction(async (tx) => {\n    // Create campaign\n    const campaign = await tx.campaign.create({\n      data: {\n        name: campaignData.name,\n        description: campaignData.description,\n        meta: {},\n        templates: {\n          create: campaignData.templates.map(template => ({\n            name: template.name,\n            subject: template.subject,\n            content: template.content,\n            htmlContent: template.htmlContent,\n            variables: template.variables,\n            meta: {}\n          }))\n        },\n        schedules: {\n          create: campaignData.schedules.map(schedule => ({\n            groupId: schedule.groupId,\n            name: schedule.name,\n            description: schedule.description,\n            scheduledAt: schedule.scheduledAt,\n            meta: {}\n          }))\n        }\n      },\n      include: {\n        templates: true,\n        schedules: {\n          include: {\n            group: {\n              include: {\n                _count: {\n                  select: { members: true }\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n    \n    // Create email jobs for each schedule\n    for (const schedule of campaign.schedules) {\n      const members = await tx.audienceMember.findMany({\n        where: {\n          groupId: schedule.groupId,\n          unsubscribed: false\n        }\n      });\n      \n      // Create send record\n      const send = await tx.campaignSend.create({\n        data: {\n          scheduleId: schedule.id,\n          meta: {}\n        }\n      });\n      \n      // Create email jobs for each member\n      await tx.emailJob.createMany({\n        data: members.map(member => ({\n          sendId: send.id,\n          memberId: member.id,\n          meta: {}\n        }))\n      });\n    }\n    \n    return campaign;\n  });\n}\n```\n\n**4. DATABASE MIGRATION PATTERNS**\n```typescript\n// Migration utilities and patterns\n// src/lib/database/migrations.ts\n\n// Data migration for schema changes\nexport async function migrateAudienceGroupCriteria() {\n  const groups = await prisma.audienceGroup.findMany({\n    where: {\n      criteria: null\n    }\n  });\n  \n  for (const group of groups) {\n    await prisma.audienceGroup.update({\n      where: { id: group.id },\n      data: {\n        criteria: {}\n      }\n    });\n  }\n  \n  console.log(`Migrated ${groups.length} audience groups`);\n}\n\n// Seed data for development\nexport async function seedDevelopmentData() {\n  if (process.env.NODE_ENV !== 'development') {\n    throw new Error('Seed data can only be created in development');\n  }\n  \n  // Create sample audience group\n  const techGroup = await prisma.audienceGroup.create({\n    data: {\n      name: 'Tech Companies',\n      description: 'Technology companies in Northern BC',\n      color: '#3b82f6',\n      criteria: {\n        tags: ['technology', 'software', 'IT'],\n        location: 'Northern BC'\n      },\n      meta: {\n        createdBy: 'system',\n        source: 'seed'\n      }\n    }\n  });\n  \n  // Create sample campaign\n  const sampleCampaign = await prisma.campaign.create({\n    data: {\n      name: 'AI Information Session Invitation',\n      description: 'Invitation to AI in Northern BC event',\n      status: 'DRAFT',\n      meta: {\n        eventType: 'information-session',\n        targetAudience: 'tech-companies'\n      }\n    }\n  });\n  \n  console.log('Development data seeded successfully');\n  return { techGroup, sampleCampaign };\n}\n\n// Database health check\nexport async function checkDatabaseHealth() {\n  try {\n    // Test basic connection\n    await prisma.$queryRaw`SELECT 1`;\n    \n    // Check table counts\n    const [campaigns, groups, members, rsvps] = await Promise.all([\n      prisma.campaign.count(),\n      prisma.audienceGroup.count(),\n      prisma.audienceMember.count(),\n      prisma.rsvp.count()\n    ]);\n    \n    return {\n      status: 'healthy',\n      connection: 'active',\n      counts: {\n        campaigns,\n        groups,\n        members,\n        rsvps\n      },\n      timestamp: new Date().toISOString()\n    };\n  } catch (error) {\n    return {\n      status: 'unhealthy',\n      error: error.message,\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n```\n\n**5. DATABASE OPTIMIZATION PATTERNS**\n```typescript\n// Query optimization and indexing strategies\n// src/lib/database/optimization.ts\n\n// Batch operations for performance\nexport async function bulkUpdateAudienceMembers(\n  updates: Array<{\n    id: string;\n    data: Partial<AudienceMember>;\n  }>\n) {\n  // Process in batches to avoid overwhelming the database\n  const batchSize = 100;\n  const results = [];\n  \n  for (let i = 0; i < updates.length; i += batchSize) {\n    const batch = updates.slice(i, i + batchSize);\n    \n    const batchResults = await Promise.allSettled(\n      batch.map(update =>\n        prisma.audienceMember.update({\n          where: { id: update.id },\n          data: update.data\n        })\n      )\n    );\n    \n    results.push(...batchResults);\n  }\n  \n  return {\n    successful: results.filter(r => r.status === 'fulfilled').length,\n    failed: results.filter(r => r.status === 'rejected').length,\n    results\n  };\n}\n\n// Efficient pagination with cursor-based approach\nexport async function getAudienceMembersCursor(\n  groupId: string,\n  cursor?: string,\n  limit: number = 50\n) {\n  const whereClause: any = { groupId };\n  \n  if (cursor) {\n    whereClause.id = {\n      lt: cursor // Assuming descending order by ID\n    };\n  }\n  \n  const members = await prisma.audienceMember.findMany({\n    where: whereClause,\n    take: limit + 1, // Take one extra to check if there are more\n    orderBy: { id: 'desc' },\n    include: {\n      group: {\n        select: {\n          name: true,\n          color: true\n        }\n      }\n    }\n  });\n  \n  const hasNextPage = members.length > limit;\n  const nextCursor = hasNextPage ? members[limit - 1].id : null;\n  \n  return {\n    members: hasNextPage ? members.slice(0, -1) : members,\n    nextCursor,\n    hasNextPage\n  };\n}\n\n// Database connection pooling configuration\n// src/lib/database/connection.ts\nconst connectionConfig = {\n  // Connection pool settings\n  connectionLimit: 10,\n  acquireTimeoutMillis: 30000,\n  timeout: 30000,\n  \n  // Query optimization\n  queryTimeout: 30000,\n  \n  // Retry configuration\n  retryAttempts: 3,\n  retryDelay: 1000,\n};\n\n// Connection health monitoring\nexport class DatabaseHealthMonitor {\n  private static instance: DatabaseHealthMonitor;\n  private healthStatus: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n  private lastHealthCheck: Date = new Date();\n  \n  static getInstance(): DatabaseHealthMonitor {\n    if (!DatabaseHealthMonitor.instance) {\n      DatabaseHealthMonitor.instance = new DatabaseHealthMonitor();\n    }\n    return DatabaseHealthMonitor.instance;\n  }\n  \n  async checkHealth(): Promise<{\n    status: string;\n    responseTime: number;\n    timestamp: string;\n  }> {\n    const startTime = Date.now();\n    \n    try {\n      await prisma.$queryRaw`SELECT 1`;\n      const responseTime = Date.now() - startTime;\n      \n      this.healthStatus = responseTime < 1000 ? 'healthy' : 'degraded';\n      this.lastHealthCheck = new Date();\n      \n      return {\n        status: this.healthStatus,\n        responseTime,\n        timestamp: this.lastHealthCheck.toISOString()\n      };\n    } catch (error) {\n      this.healthStatus = 'unhealthy';\n      this.lastHealthCheck = new Date();\n      \n      return {\n        status: 'unhealthy',\n        responseTime: Date.now() - startTime,\n        timestamp: this.lastHealthCheck.toISOString()\n      };\n    }\n  }\n  \n  getStatus() {\n    return {\n      status: this.healthStatus,\n      lastCheck: this.lastHealthCheck\n    };\n  }\n}\n```\n\n**6. DATA FLOW AND INTERCONNECTIONS**\n```typescript\n// How data flows through the system\n// src/lib/database/dataFlow.ts\n\n// Complete RSVP processing flow\nexport async function processRSVPSubmission(rsvpData: any) {\n  return await prisma.$transaction(async (tx) => {\n    // 1. Create RSVP record\n    const rsvp = await tx.rsvp.create({\n      data: {\n        fullName: `${rsvpData.firstName} ${rsvpData.lastName}`,\n        organization: rsvpData.organization,\n        email: rsvpData.email,\n        phone: rsvpData.phone,\n        attendanceStatus: rsvpData.attendanceStatus,\n        attendeeCount: rsvpData.attendeeCount,\n        dietaryPreference: rsvpData.dietaryPreference,\n        dietaryOther: rsvpData.dietaryOther,\n        accessibilityNeeds: rsvpData.accessibilityNeeds,\n        referralSource: rsvpData.referralSource,\n        referralOther: rsvpData.referralOther,\n        wantsResources: rsvpData.wantsResources,\n        wantsAudit: rsvpData.wantsAudit,\n        learningGoal: rsvpData.learningGoal,\n        ipHash: rsvpData.ipHash,\n        userAgent: rsvpData.userAgent,\n        utmSource: rsvpData.utmSource,\n        utmMedium: rsvpData.utmMedium,\n        utmCampaign: rsvpData.utmCampaign,\n        utmContent: rsvpData.utmContent,\n        utmTerm: rsvpData.utmTerm,\n        referrer: rsvpData.referrer,\n        meta: {\n          submittedAt: new Date().toISOString(),\n          source: 'rsvp-form'\n        }\n      }\n    });\n    \n    // 2. Create visit record for analytics\n    if (rsvpData.visitData) {\n      await tx.visit.create({\n        data: {\n          visitorId: rsvpData.visitData.visitorId,\n          sessionId: rsvpData.visitData.sessionId,\n          page: 'rsvp-confirmation',\n          referrer: rsvpData.referrer,\n          utmSource: rsvpData.utmSource,\n          utmMedium: rsvpData.utmMedium,\n          utmCampaign: rsvpData.utmCampaign,\n          utmContent: rsvpData.utmContent,\n          utmTerm: rsvpData.utmTerm,\n          device: rsvpData.visitData.device,\n          browser: rsvpData.visitData.browser,\n          os: rsvpData.visitData.os,\n          country: rsvpData.visitData.country,\n          region: rsvpData.visitData.region,\n          city: rsvpData.visitData.city,\n          language: rsvpData.visitData.language,\n          screenResolution: rsvpData.visitData.screenResolution,\n          viewportSize: rsvpData.visitData.viewportSize,\n          connectionType: rsvpData.visitData.connectionType,\n          loadTime: rsvpData.visitData.loadTime,\n          bounceRate: rsvpData.visitData.bounceRate,\n          timeOnPage: rsvpData.visitData.timeOnPage,\n          scrollDepth: rsvpData.visitData.scrollDepth,\n          clickCount: rsvpData.visitData.clickCount,\n          meta: rsvpData.visitData.meta\n        }\n      });\n    }\n    \n    // 3. Update audience member if exists\n    if (rsvpData.businessId && rsvpData.groupId) {\n      await tx.audienceMember.updateMany({\n        where: {\n          groupId: rsvpData.groupId,\n          businessId: rsvpData.businessId\n        },\n        data: {\n          meta: {\n            lastRsvpDate: new Date().toISOString(),\n            rsvpStatus: rsvpData.attendanceStatus,\n            attendeeCount: rsvpData.attendeeCount\n          }\n        }\n      });\n    }\n    \n    return rsvp;\n  });\n}\n\n// Campaign execution flow\nexport async function executeCampaignSend(sendId: string) {\n  return await prisma.$transaction(async (tx) => {\n    // 1. Get send details with all relationships\n    const send = await tx.campaignSend.findUnique({\n      where: { id: sendId },\n      include: {\n        schedule: {\n          include: {\n            campaign: {\n              include: {\n                templates: true\n              }\n            },\n            group: {\n              include: {\n                members: {\n                  where: { unsubscribed: false }\n                }\n              }\n            }\n          }\n        },\n        jobs: {\n          include: {\n            member: true,\n            events: true\n          }\n        }\n      }\n    });\n    \n    if (!send) {\n      throw new Error('Send not found');\n    }\n    \n    // 2. Update send status to running\n    await tx.campaignSend.update({\n      where: { id: sendId },\n      data: {\n        status: 'RUNNING'\n      }\n    });\n    \n    // 3. Process each email job\n    for (const job of send.jobs) {\n      try {\n        // Update job status to sending\n        await tx.emailJob.update({\n          where: { id: job.id },\n          data: { status: 'SENDING' }\n        });\n        \n        // Send email (this would call the email service)\n        const emailResult = await sendCampaignEmail({\n          jobId: job.id,\n          member: job.member,\n          template: send.schedule.campaign.templates[0],\n          campaign: send.schedule.campaign\n        });\n        \n        // Record email event\n        await tx.emailEvent.create({\n          data: {\n            jobId: job.id,\n            type: 'SENT',\n            data: {\n              emailId: emailResult.id,\n              sentAt: new Date().toISOString()\n            }\n          }\n        });\n        \n        // Update job status\n        await tx.emailJob.update({\n          where: { id: job.id },\n          data: {\n            status: 'SENT',\n            sentAt: new Date()\n          }\n        });\n        \n      } catch (error) {\n        // Record error event\n        await tx.emailEvent.create({\n          data: {\n            jobId: job.id,\n            type: 'FAILED',\n            data: {\n              error: error.message,\n              failedAt: new Date().toISOString()\n            }\n          }\n        });\n        \n        // Update job status\n        await tx.emailJob.update({\n          where: { id: job.id },\n          data: { status: 'FAILED' }\n        });\n      }\n    }\n    \n    // 4. Update send status to completed\n    await tx.campaignSend.update({\n      where: { id: sendId },\n      data: {\n        status: 'COMPLETED',\n        sentAt: new Date()\n      }\n    });\n    \n    return send;\n  });\n}\n```\n\nThis comprehensive database operations system provides efficient data management with proper relationships, transactions, optimization, and monitoring for the RSVP application."}

