{"instruction": "How do API routes work in this application?", "input": "Explain the complete API routing system including Next.js API routes, middleware, authentication, and request/response patterns", "output": "I'll explain the comprehensive API routing system. Here's how Next.js API routes are structured and how they handle requests:\n\n**API ROUTING ARCHITECTURE**\n\n**1. NEXT.JS API ROUTE STRUCTURE**\n```typescript\n// API route handler pattern\n// src/app/api/[route]/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { requireAdminSession } from '@/lib/adminSession';\nimport { createSecureResponse } from '@/lib/security-headers';\nimport prisma from '@/lib/prisma';\n\n// HTTP method handlers\nexport async function GET(request: NextRequest) {\n  try {\n    // Parse query parameters\n    const { searchParams } = new URL(request.url);\n    const page = parseInt(searchParams.get('page') || '1');\n    const limit = parseInt(searchParams.get('limit') || '10');\n    const search = searchParams.get('search') || '';\n    \n    // Get data from database\n    const data = await getData({ page, limit, search });\n    \n    // Return response with security headers\n    return createSecureResponse({ data, pagination: { page, limit } });\n  } catch (error) {\n    console.error('GET /api/[route] error:', error);\n    return createSecureResponse(\n      { error: 'Failed to fetch data' },\n      500\n    );\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Parse request body\n    const body = await request.json();\n    \n    // Validate input\n    const validatedData = validateInput(body);\n    \n    // Process request\n    const result = await processData(validatedData);\n    \n    return createSecureResponse({ result }, 201);\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      return createSecureResponse(\n        { error: 'Validation failed', details: error.details },\n        400\n      );\n    }\n    \n    console.error('POST /api/[route] error:', error);\n    return createSecureResponse(\n      { error: 'Internal server error' },\n      500\n    );\n  }\n}\n\nexport async function PUT(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { searchParams } = new URL(request.url);\n    const id = searchParams.get('id');\n    \n    if (!id) {\n      return createSecureResponse(\n        { error: 'ID parameter is required' },\n        400\n      );\n    }\n    \n    const result = await updateData(id, body);\n    \n    return createSecureResponse({ result });\n  } catch (error) {\n    console.error('PUT /api/[route] error:', error);\n    return createSecureResponse(\n      { error: 'Failed to update data' },\n      500\n    );\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const id = searchParams.get('id');\n    \n    if (!id) {\n      return createSecureResponse(\n        { error: 'ID parameter is required' },\n        400\n      );\n    }\n    \n    await deleteData(id);\n    \n    return createSecureResponse({ success: true }, 204);\n  } catch (error) {\n    console.error('DELETE /api/[route] error:', error);\n    return createSecureResponse(\n      { error: 'Failed to delete data' },\n      500\n    );\n  }\n}\n```\n\n**2. MIDDLEWARE INTEGRATION**\n```typescript\n// Next.js middleware for API routes\n// middleware.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { verifySessionToken } from '@/lib/admin-auth';\n\nexport function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl;\n  \n  // Admin route protection\n  if (pathname.startsWith('/api/admin')) {\n    const token = request.cookies.get('admin-session')?.value;\n    \n    if (!token) {\n      return NextResponse.json(\n        { error: 'Authentication required' },\n        { status: 401 }\n      );\n    }\n    \n    try {\n      const session = verifySessionToken(token);\n      if (!session) {\n        return NextResponse.json(\n          { error: 'Invalid session' },\n          { status: 401 }\n        );\n      }\n      \n      // Add session info to headers\n      const response = NextResponse.next();\n      response.headers.set('x-admin-user', session.username);\n      return response;\n    } catch (error) {\n      return NextResponse.json(\n        { error: 'Authentication failed' },\n        { status: 401 }\n      );\n    }\n  }\n  \n  // Rate limiting for public APIs\n  if (pathname.startsWith('/api/rsvp')) {\n    const clientIP = request.headers.get('x-forwarded-for')?.split(',')[0] || 'unknown';\n    \n    // Check rate limit (implement your rate limiting logic)\n    if (isRateLimited(clientIP)) {\n      return NextResponse.json(\n        { error: 'Rate limit exceeded' },\n        { status: 429 }\n      );\n    }\n  }\n  \n  // Security headers for all responses\n  const response = NextResponse.next();\n  \n  response.headers.set('X-Content-Type-Options', 'nosniff');\n  response.headers.set('X-Frame-Options', 'DENY');\n  response.headers.set('X-XSS-Protection', '1; mode=block');\n  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');\n  \n  return response;\n}\n\nexport const config = {\n  matcher: [\n    '/api/((?!_next/static|_next/image|favicon.ico).*)',\n    '/admin/:path*'\n  ]\n};\n```\n\n**3. AUTHENTICATION MIDDLEWARE**\n```typescript\n// Admin session middleware\n// src/lib/adminSession.ts\nimport { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { verifySessionToken, getAdminConfig } from '@/lib/admin-auth';\n\nexport function requireAdminSession() {\n  const token = cookies().get(getSessionCookieName())?.value;\n  const config = getAdminConfig();\n  \n  if (!config) {\n    return { \n      response: NextResponse.json(\n        { error: 'Admin not configured' }, \n        { status: 500 }\n      ) \n    };\n  }\n  \n  if (!token) {\n    return { \n      response: NextResponse.json(\n        { error: 'Authentication required' }, \n        { status: 401 }\n      ) \n    };\n  }\n  \n  const session = verifySessionToken(token, config.sessionSecret);\n  if (!session) {\n    return { \n      response: NextResponse.json(\n        { error: 'Invalid session' }, \n        { status: 401 }\n      ) \n    };\n  }\n  \n  return { session };\n}\n\n// CSRF protection middleware\n// src/lib/csrf-protection.ts\nexport function validateCSRF(request: NextRequest): boolean {\n  const origin = request.headers.get('origin');\n  const referer = request.headers.get('referer');\n  \n  const allowedOrigins = [\n    'http://localhost:3000',\n    'http://localhost:3001',\n    'https://rsvp.evergreenwebsolutions.ca'\n  ];\n  \n  const isValidOrigin = !origin || allowedOrigins.some(allowed => origin.startsWith(allowed));\n  const isValidReferer = !referer || allowedOrigins.some(allowed => referer.startsWith(allowed));\n  \n  return isValidOrigin || isValidReferer;\n}\n\n// Rate limiting middleware\n// src/lib/rate-limiter.ts\nexport function checkRateLimit(\n  clientIP: string,\n  endpoint: string,\n  limit: number = 100,\n  windowMs: number = 15 * 60 * 1000 // 15 minutes\n): boolean {\n  // Implement your rate limiting logic here\n  // This could use Redis, in-memory store, or database\n  const key = `${endpoint}:${clientIP}`;\n  const now = Date.now();\n  \n  // Check if request is within rate limit\n  // Return true if allowed, false if rate limited\n  return true; // Simplified for example\n}\n```\n\n**4. REQUEST/RESPONSE PATTERNS**\n```typescript\n// Standardized request/response handling\n// src/lib/api-handlers.ts\n\n// Request parsing utilities\nexport async function parseRequestBody<T>(request: NextRequest): Promise<T> {\n  try {\n    const body = await request.json();\n    return body as T;\n  } catch (error) {\n    throw new Error('Invalid JSON in request body');\n  }\n}\n\nexport function parseQueryParams(request: NextRequest): Record<string, string> {\n  const { searchParams } = new URL(request.url);\n  const params: Record<string, string> = {};\n  \n  searchParams.forEach((value, key) => {\n    params[key] = value;\n  });\n  \n  return params;\n}\n\n// Response formatting utilities\nexport function createSuccessResponse<T>(\n  data: T,\n  status: number = 200,\n  meta?: Record<string, any>\n): NextResponse {\n  const response = {\n    success: true,\n    data,\n    ...(meta && { meta }),\n    timestamp: new Date().toISOString()\n  };\n  \n  return NextResponse.json(response, { status });\n}\n\nexport function createErrorResponse(\n  message: string,\n  status: number = 500,\n  details?: any\n): NextResponse {\n  const response = {\n    success: false,\n    error: message,\n    ...(details && { details }),\n    timestamp: new Date().toISOString()\n  };\n  \n  return NextResponse.json(response, { status });\n}\n\n// Validation error response\nexport function createValidationErrorResponse(\n  errors: Record<string, string>\n): NextResponse {\n  return createErrorResponse(\n    'Validation failed',\n    400,\n    { validationErrors: errors }\n  );\n}\n\n// Pagination response\nexport function createPaginatedResponse<T>(\n  data: T[],\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n    pages: number;\n  }\n): NextResponse {\n  return createSuccessResponse(data, 200, {\n    pagination: {\n      currentPage: pagination.page,\n      limit: pagination.limit,\n      totalItems: pagination.total,\n      totalPages: pagination.pages,\n      hasNextPage: pagination.page < pagination.pages,\n      hasPreviousPage: pagination.page > 1\n    }\n  });\n}\n```\n\n**5. API ROUTE IMPLEMENTATIONS**\n```typescript\n// Campaign management API routes\n// src/app/api/admin/campaign/campaigns/route.ts\nexport async function GET(request: NextRequest) {\n  const auth = requireAdminSession();\n  if ('response' in auth) return auth.response;\n  \n  try {\n    const params = parseQueryParams(request);\n    const { page = '1', limit = '10', status, search } = params;\n    \n    const whereClause: any = {};\n    \n    if (status) {\n      whereClause.status = status;\n    }\n    \n    if (search) {\n      whereClause.OR = [\n        { name: { contains: search, mode: 'insensitive' } },\n        { description: { contains: search, mode: 'insensitive' } }\n      ];\n    }\n    \n    const [campaigns, total] = await Promise.all([\n      prisma.campaign.findMany({\n        where: whereClause,\n        include: {\n          templates: {\n            select: { id: true, name: true, subject: true }\n          },\n          schedules: {\n            include: {\n              group: {\n                select: { id: true, name: true, _count: { select: { members: true } } }\n              },\n              _count: { select: { sends: true } }\n            }\n          },\n          _count: {\n            select: {\n              templates: true,\n              schedules: true\n            }\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        skip: (parseInt(page) - 1) * parseInt(limit),\n        take: parseInt(limit)\n      }),\n      prisma.campaign.count({ where: whereClause })\n    ]);\n    \n    return createPaginatedResponse(campaigns, {\n      page: parseInt(page),\n      limit: parseInt(limit),\n      total,\n      pages: Math.ceil(total / parseInt(limit))\n    });\n    \n  } catch (error) {\n    console.error('Error fetching campaigns:', error);\n    return createErrorResponse('Failed to fetch campaigns');\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  const auth = requireAdminSession();\n  if ('response' in auth) return auth.response;\n  \n  try {\n    const body = await parseRequestBody<{\n      name: string;\n      description?: string;\n      templates: Array<{\n        name: string;\n        subject: string;\n        content: string;\n        htmlContent?: string;\n        variables: any;\n      }>;\n      schedules: Array<{\n        groupId: string;\n        name: string;\n        description?: string;\n        scheduledAt: string;\n      }>;\n    }>(request);\n    \n    // Validate required fields\n    if (!body.name) {\n      return createValidationErrorResponse({\n        name: 'Campaign name is required'\n      });\n    }\n    \n    if (!body.templates || body.templates.length === 0) {\n      return createValidationErrorResponse({\n        templates: 'At least one template is required'\n      });\n    }\n    \n    // Create campaign with templates and schedules\n    const campaign = await createCampaignWithSchedule({\n      name: body.name,\n      description: body.description,\n      templates: body.templates,\n      schedules: body.schedules.map(schedule => ({\n        ...schedule,\n        scheduledAt: new Date(schedule.scheduledAt)\n      }))\n    });\n    \n    return createSuccessResponse(campaign, 201);\n    \n  } catch (error) {\n    console.error('Error creating campaign:', error);\n    return createErrorResponse('Failed to create campaign');\n  }\n}\n\n// RSVP submission API route\n// src/app/api/rsvp/route.ts\nexport async function POST(request: NextRequest) {\n  try {\n    // Security checks\n    const clientIP = request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() || 'unknown';\n    \n    // CSRF protection\n    if (!validateCSRF(request)) {\n      logCSRFViolation(clientIP, '/api/rsvp');\n      return createSecureResponse(\n        { error: 'Invalid request origin' },\n        403\n      );\n    }\n    \n    // Rate limiting\n    if (!checkRateLimit(clientIP, '/api/rsvp', 5, 60 * 1000)) {\n      logRateLimitViolation(clientIP, '/api/rsvp');\n      return createSecureResponse(\n        { error: 'Rate limit exceeded' },\n        429\n      );\n    }\n    \n    // Parse and validate request body\n    const body = await parseRequestBody<RSVPFormData>(request);\n    const validatedData = rsvpSchema.parse(body);\n    \n    // Additional security checks\n    if (validatedData.email.length > 254) {\n      logInvalidInput(clientIP, '/api/rsvp', { email: 'too long' });\n      return createSecureResponse(\n        { error: 'Invalid email format' },\n        400\n      );\n    }\n    \n    // Check for potential XSS\n    const textFields = ['firstName', 'lastName', 'organization', 'learningGoal'];\n    for (const field of textFields) {\n      if (validatedData[field] && /<script|javascript:|on\\w+=/i.test(validatedData[field])) {\n        logXSSAttempt(clientIP, '/api/rsvp', validatedData[field]);\n        return createSecureResponse(\n          { error: 'Invalid input detected' },\n          400\n        );\n      }\n    }\n    \n    // Process RSVP submission\n    const rsvp = await processRSVPSubmission({\n      ...validatedData,\n      ipHash: hashIPAddress(clientIP),\n      userAgent: request.headers.get('user-agent') || '',\n      utmSource: request.headers.get('utm-source') || '',\n      utmMedium: request.headers.get('utm-medium') || '',\n      utmCampaign: request.headers.get('utm-campaign') || '',\n      utmContent: request.headers.get('utm-content') || '',\n      utmTerm: request.headers.get('utm-term') || '',\n      referrer: request.headers.get('referer') || ''\n    });\n    \n    // Send confirmation email asynchronously\n    sendRSVPConfirmation(rsvp).catch(error => {\n      console.error('Failed to send confirmation email:', error);\n    });\n    \n    // Post to LeadMine asynchronously\n    postLeadMineEvent({\n      type: 'rsvp_submitted',\n      data: {\n        rsvpId: rsvp.id,\n        businessName: rsvp.organization,\n        email: rsvp.email,\n        attendanceStatus: rsvp.attendanceStatus\n      }\n    }).catch(error => {\n      console.error('Failed to post to LeadMine:', error);\n    });\n    \n    return createSecureResponse({\n      success: true,\n      rsvpId: rsvp.id,\n      message: 'RSVP submitted successfully'\n    }, 201);\n    \n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const fieldErrors = error.errors.reduce((acc, err) => {\n        acc[err.path[0]] = err.message;\n        return acc;\n      }, {} as Record<string, string>);\n      \n      return createSecureResponse({\n        error: 'Validation failed',\n        fieldErrors\n      }, 400);\n    }\n    \n    if (error.code === 'P2002') {\n      return createSecureResponse({\n        error: 'Email already exists',\n        fieldErrors: { email: 'This email has already been used for an RSVP' }\n      }, 409);\n    }\n    \n    console.error('RSVP processing error:', error);\n    return createSecureResponse({\n      error: 'Internal server error'\n    }, 500);\n  }\n}\n```\n\n**6. ERROR HANDLING AND LOGGING**\n```typescript\n// Comprehensive error handling\n// src/lib/api-error-handler.ts\n\nexport class APIError extends Error {\n  public statusCode: number;\n  public isOperational: boolean;\n  \n  constructor(message: string, statusCode: number = 500, isOperational: boolean = true) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = isOperational;\n    \n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport function handleAPIError(error: any): NextResponse {\n  // Log error for monitoring\n  console.error('API Error:', {\n    message: error.message,\n    stack: error.stack,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Handle known error types\n  if (error instanceof APIError) {\n    return createErrorResponse(error.message, error.statusCode);\n  }\n  \n  if (error instanceof z.ZodError) {\n    const fieldErrors = error.errors.reduce((acc, err) => {\n      acc[err.path[0]] = err.message;\n      return acc;\n    }, {} as Record<string, string>);\n    \n    return createValidationErrorResponse(fieldErrors);\n  }\n  \n  if (error.code === 'P2002') {\n    return createErrorResponse('Duplicate entry', 409);\n  }\n  \n  if (error.code === 'P2025') {\n    return createErrorResponse('Record not found', 404);\n  }\n  \n  // Generic error response\n  return createErrorResponse(\n    process.env.NODE_ENV === 'production' \n      ? 'Internal server error' \n      : error.message\n  );\n}\n\n// Request logging middleware\n// src/lib/request-logger.ts\nexport function logRequest(request: NextRequest, response: NextResponse, duration: number) {\n  const { pathname, searchParams } = new URL(request.url);\n  const method = request.method;\n  const status = response.status;\n  const clientIP = request.headers.get('x-forwarded-for')?.split(',')[0] || 'unknown';\n  const userAgent = request.headers.get('user-agent') || '';\n  \n  const logEntry = {\n    timestamp: new Date().toISOString(),\n    method,\n    path: pathname,\n    query: Object.fromEntries(searchParams),\n    status,\n    duration,\n    clientIP,\n    userAgent: userAgent.substring(0, 100), // Truncate for storage\n    referer: request.headers.get('referer') || ''\n  };\n  \n  // Log to console in development\n  if (process.env.NODE_ENV === 'development') {\n    console.log(`${method} ${pathname} ${status} ${duration}ms`);\n  }\n  \n  // Log to monitoring service in production\n  // This could be sent to a logging service like Datadog, LogRocket, etc.\n}\n```\n\n**7. API ROUTE TESTING PATTERNS**\n```typescript\n// API route testing utilities\n// src/lib/test-utils/api-testing.ts\nimport { NextRequest } from 'next/server';\n\nexport function createMockRequest(\n  method: string = 'GET',\n  url: string = '/api/test',\n  body?: any,\n  headers: Record<string, string> = {}\n): NextRequest {\n  const request = new NextRequest(url, {\n    method,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers\n    },\n    ...(body && { body: JSON.stringify(body) })\n  });\n  \n  return request;\n}\n\nexport async function testAPIEndpoint(\n  handler: (request: NextRequest) => Promise<NextResponse>,\n  request: NextRequest,\n  expectedStatus: number = 200\n): Promise<{\n  response: NextResponse;\n  data: any;\n  status: number;\n}> {\n  const response = await handler(request);\n  const data = await response.json();\n  \n  expect(response.status).toBe(expectedStatus);\n  \n  return {\n    response,\n    data,\n    status: response.status\n  };\n}\n\n// Example API route test\n// src/app/api/__tests__/campaigns.test.ts\ndescribe('/api/admin/campaign/campaigns', () => {\n  beforeEach(() => {\n    // Mock admin session\n    jest.mock('@/lib/adminSession', () => ({\n      requireAdminSession: () => ({ session: { username: 'admin' } })\n    }));\n  });\n  \n  describe('GET', () => {\n    it('should return campaigns with pagination', async () => {\n      const request = createMockRequest('GET', '/api/admin/campaign/campaigns?page=1&limit=10');\n      \n      const { data } = await testAPIEndpoint(GET, request);\n      \n      expect(data.success).toBe(true);\n      expect(data.data).toBeInstanceOf(Array);\n      expect(data.meta.pagination).toBeDefined();\n      expect(data.meta.pagination.currentPage).toBe(1);\n    });\n    \n    it('should filter campaigns by status', async () => {\n      const request = createMockRequest('GET', '/api/admin/campaign/campaigns?status=DRAFT');\n      \n      const { data } = await testAPIEndpoint(GET, request);\n      \n      expect(data.success).toBe(true);\n      expect(data.data.every((campaign: any) => campaign.status === 'DRAFT')).toBe(true);\n    });\n  });\n  \n  describe('POST', () => {\n    it('should create a new campaign', async () => {\n      const campaignData = {\n        name: 'Test Campaign',\n        description: 'Test Description',\n        templates: [{\n          name: 'Test Template',\n          subject: 'Test Subject',\n          content: 'Test Content',\n          variables: {}\n        }],\n        schedules: []\n      };\n      \n      const request = createMockRequest('POST', '/api/admin/campaign/campaigns', campaignData);\n      \n      const { data } = await testAPIEndpoint(POST, request, 201);\n      \n      expect(data.success).toBe(true);\n      expect(data.data.name).toBe('Test Campaign');\n    });\n    \n    it('should validate required fields', async () => {\n      const invalidData = {\n        description: 'Missing name'\n      };\n      \n      const request = createMockRequest('POST', '/api/admin/campaign/campaigns', invalidData);\n      \n      const { data } = await testAPIEndpoint(POST, request, 400);\n      \n      expect(data.success).toBe(false);\n      expect(data.details.validationErrors.name).toBeDefined();\n    });\n  });\n});\n```\n\n**8. API ROUTE INTERCONNECTIONS**\n```typescript\n// How API routes work together\n// src/lib/api-workflows.ts\n\n// Complete campaign creation workflow\nexport async function createCampaignWorkflow(campaignData: any) {\n  // 1. Validate campaign data\n  const validatedData = await validateCampaignData(campaignData);\n  \n  // 2. Create campaign via API\n  const campaignResponse = await fetch('/api/admin/campaign/campaigns', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(validatedData)\n  });\n  \n  if (!campaignResponse.ok) {\n    throw new Error('Failed to create campaign');\n  }\n  \n  const campaign = await campaignResponse.json();\n  \n  // 3. Create audience groups if needed\n  for (const schedule of campaignData.schedules) {\n    if (schedule.createGroup) {\n      const groupResponse = await fetch('/api/admin/campaign/groups', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(schedule.groupData)\n      });\n      \n      if (!groupResponse.ok) {\n        throw new Error('Failed to create audience group');\n      }\n      \n      const group = await groupResponse.json();\n      schedule.groupId = group.data.id;\n    }\n  }\n  \n  // 4. Update campaign with group IDs\n  const updateResponse = await fetch(`/api/admin/campaign/campaigns?id=${campaign.data.id}`, {\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ schedules: campaignData.schedules })\n  });\n  \n  if (!updateResponse.ok) {\n    throw new Error('Failed to update campaign schedules');\n  }\n  \n  // 5. Schedule campaign sends\n  const scheduleResponse = await fetch('/api/admin/campaign/schedules', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      campaignId: campaign.data.id,\n      schedules: campaignData.schedules\n    })\n  });\n  \n  if (!scheduleResponse.ok) {\n    throw new Error('Failed to schedule campaign');\n  }\n  \n  return campaign;\n}\n\n// RSVP processing workflow\nexport async function processRSVPWorkflow(rsvpData: any) {\n  // 1. Submit RSVP\n  const rsvpResponse = await fetch('/api/rsvp', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(rsvpData)\n  });\n  \n  if (!rsvpResponse.ok) {\n    const error = await rsvpResponse.json();\n    throw new Error(error.error || 'Failed to submit RSVP');\n  }\n  \n  const rsvp = await rsvpResponse.json();\n  \n  // 2. Track analytics\n  await fetch('/api/track/visit', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      visitorId: rsvpData.visitorId,\n      sessionId: rsvpData.sessionId,\n      page: 'rsvp-confirmation',\n      action: 'rsvp-submitted',\n      meta: {\n        rsvpId: rsvp.rsvpId,\n        attendanceStatus: rsvpData.attendanceStatus\n      }\n    })\n  });\n  \n  // 3. Send confirmation email (handled asynchronously by API)\n  // 4. Post to LeadMine (handled asynchronously by API)\n  \n  return rsvp;\n}\n```\n\nThis comprehensive API routing system provides secure, scalable, and maintainable API endpoints with proper authentication, validation, error handling, and testing for the RSVP application."}

